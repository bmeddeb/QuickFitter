<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dielectric Data Fitter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .btn-disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Style for parameter sliders */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Interactive Dielectric Data Fitter</h1>
            <p class="mt-2 text-lg text-gray-600">Upload your dielectric spectroscopy data (CSV) to fit it to the Djordjevic-Sarkar model.</p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
            <!-- Controls Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center mb-6">
                <div>
                    <label for="file-upload" class="block text-sm font-medium text-gray-700 mb-2">
                        Upload CSV File
                    </label>
                    <div class="flex items-center space-x-4">
                        <input type="file" id="file-upload" accept=".csv" class="block w-full text-sm text-gray-500
                            file:mr-4 file:py-2 file:px-4
                            file:rounded-lg file:border-0
                            file:text-sm file:font-semibold
                            file:bg-blue-50 file:text-blue-700
                            hover:file:bg-blue-100
                        ">
                    </div>
                     <p class="text-xs text-gray-500 mt-2">Expected columns: Frequency (GHz), Dk, Df</p>
                </div>
                <div class="space-y-4">
                     <div>
                        <label for="fit-method" class="block text-sm font-medium text-gray-700">Optimization Method</label>
                        <select id="fit-method" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="least_squares" selected>least_squares (Default)</option>
                            <option value="nelder">nelder</option>
                            <option value="lbfgsb">lbfgsb</option>
                        </select>
                    </div>
                    <button id="run-button" class="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Run Analysis
                    </button>
                </div>
            </div>

            <!-- Status and Output Section -->
            <div id="status" class="text-center my-4 p-4 bg-gray-50 rounded-lg hidden">
                <div class="flex items-center justify-center">
                    <div class="spinner w-6 h-6 rounded-full border-4 border-gray-300"></div>
                    <p id="status-message" class="ml-4 text-gray-700 font-medium"></p>
                </div>
            </div>

            <div id="output" class="hidden mt-8">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- Plot Display -->
                    <div id="plot-container" class="lg:col-span-2 border border-gray-200 rounded-lg bg-gray-50 p-2">
                         <div id="plot-output"></div>
                    </div>

                    <!-- Parameter Controls -->
                    <div id="controls-panel" class="lg:col-span-1 bg-white p-6 rounded-lg border">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-gray-800">Adjust Fit Parameters</h3>
                            <div class="flex space-x-2">
                                <button id="reset-button" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-1 px-3 rounded-lg">
                                    Reset
                                </button>
                                <button id="download-button" class="text-sm bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 px-3 rounded-lg">
                                    Download
                                </button>
                            </div>
                        </div>
                        
                        <!-- Fit Quality Indicator -->
                        <div id="fit-quality-indicator" class="mb-4 p-3 rounded-lg hidden">
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium">Fit Quality:</span>
                                <span id="fit-quality-score" class="text-lg font-bold"></span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div id="fit-quality-bar" class="h-2 rounded-full transition-all duration-300"></div>
                            </div>
                        </div>
                        
                        <div class="space-y-6">
                            <!-- eps_inf -->
                            <div>
                                <label for="eps_inf_slider" class="block text-sm font-medium text-gray-700">ε<sub>inf</sub> (Epsilon Infinity)</label>
                                <input type="range" id="eps_inf_slider" class="mt-1">
                                <input type="number" id="eps_inf_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                            <!-- delta_eps -->
                            <div>
                                <label for="delta_eps_slider" class="block text-sm font-medium text-gray-700">Δε (Delta Epsilon)</label>
                                <input type="range" id="delta_eps_slider" class="mt-1">
                                <input type="number" id="delta_eps_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                            <!-- f1 -->
                            <div>
                                <label for="omega1_slider" class="block text-sm font-medium text-gray-700">f<sub>1</sub> (GHz)</label>
                                <input type="range" id="omega1_slider" class="mt-1">
                                <input type="number" id="omega1_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                            <!-- f2 -->
                            <div>
                                <label for="omega2_slider" class="block text-sm font-medium text-gray-700">f<sub>2</sub> (GHz)</label>
                                <input type="range" id="omega2_slider" class="mt-1">
                                <input type="number" id="omega2_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Report Display -->
                <div class="mt-8">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">Fit Report</h2>
                    <div class="bg-gray-900 text-white font-mono text-sm p-6 rounded-lg overflow-x-auto">
                        <pre id="report-output"></pre>
                    </div>
                </div>
            </div>
             <!-- Error Display -->
            <div id="error-box" class="hidden mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                <h3 class="font-bold">An Error Occurred</h3>
                <p id="error-message"></p>
            </div>
        </div>
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>Powered by Pyodide, lmfit, and your original Python script.</p>
        </footer>
    </div>

    <script type="text/javascript">
        // DOM Elements
        const fileUpload = document.getElementById('file-upload');
        const runButton = document.getElementById('run-button');
        const resetButton = document.getElementById('reset-button');
        const downloadButton = document.getElementById('download-button');
        const fitMethodSelect = document.getElementById('fit-method');
        const statusDiv = document.getElementById('status');
        const statusMessage = document.getElementById('status-message');
        const outputDiv = document.getElementById('output');
        const plotOutput = document.getElementById('plot-output');
        const reportOutput = document.getElementById('report-output');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');
        
        // Parameter Controls
        const paramControls = {
            eps_inf: { slider: document.getElementById('eps_inf_slider'), input: document.getElementById('eps_inf_input') },
            delta_eps: { slider: document.getElementById('delta_eps_slider'), input: document.getElementById('delta_eps_input') },
            omega1: { slider: document.getElementById('omega1_slider'), input: document.getElementById('omega1_input') },
            omega2: { slider: document.getElementById('omega2_slider'), input: document.getElementById('omega2_input') },
        };

        // Global State
        let pyodide = null;
        let fileContent = null;
        let isPyodideReady = false;
        let currentData = null;
        let originalFilename = '';
        let originalCorrelations = null;

        // Python Script
        const pythonScript = `
import numpy as np
import pandas as pd
from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Any, Optional
from datetime import datetime
import json
import io
import math
from lmfit import Parameters, Minimizer, fit_report
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.io as pio
import logging

logger = logging.getLogger(__name__)


# ============================================================================
# Data Structures
# ============================================================================

@dataclass
class FitData:
    """Container for all fitting data"""
    f_ghz: np.ndarray
    complex_eps: np.ndarray
    measured_dk: List[float] = field(default_factory=list)
    measured_df: List[float] = field(default_factory=list)

    def __post_init__(self):
        """Calculate derived properties"""
        if len(self.measured_dk) == 0:
            self.measured_dk = np.real(self.complex_eps).tolist()
        if len(self.measured_df) == 0:
            self.measured_df = (-np.imag(self.complex_eps) / np.real(self.complex_eps)).tolist()


@dataclass
class FitParameters:
    """Djordjevic-Sarkar model parameters"""
    eps_inf: float
    delta_eps: float
    omega1: float
    omega2: float

    def to_dict(self) -> Dict[str, float]:
        return {
            'eps_inf': self.eps_inf,
            'delta_eps': self.delta_eps,
            'omega1': self.omega1,
            'omega2': self.omega2
        }

    @property
    def f1_ghz(self) -> float:
        return self.omega1 / (2 * np.pi * 1e9)

    @property
    def f2_ghz(self) -> float:
        return self.omega2 / (2 * np.pi * 1e9)


@dataclass
class MetricResult:
    """Stores the evaluation result for a single metric"""
    name: str
    score: float
    category: str
    value: float
    suggestion: Optional[str] = None
    details: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ReportEvaluation:
    """Stores the full evaluation for a report"""
    metrics: Dict[str, MetricResult]
    overall: MetricResult
    suggestions: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

    def to_markdown(self) -> str:
        """Return the evaluation as a markdown-formatted table"""
        headers = ["Metric", "Score", "Category", "Value", "Suggestion"]
        lines = ["| " + " | ".join(headers) + " |",
                 "| " + " | ".join(["---"]*len(headers)) + " |"]
        for m in self.metrics.values():
            suggestion = m.suggestion or ""
            lines.append(f"| {m.name} | {m.score} | {m.category} | {m.value:.4g} | {suggestion} |")
        lines.append(
            f"| **Overall** | {self.overall.score} | {self.overall.category} | {self.overall.value} |  |"
        )
        if self.warnings:
            lines.append("\\n**Warnings:**")
            for warning in self.warnings:
                lines.append(f"- {warning}")
        return "\\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert evaluation to dictionary format"""
        return {
            'overall_score': self.overall.score,
            'overall_category': self.overall.category,
            'metrics': {
                k: {
                    'score': v.score,
                    'category': v.category,
                    'value': v.value,
                    'suggestion': v.suggestion,
                    'details': v.details
                }
                for k, v in self.metrics.items()
            },
            'suggestions': self.suggestions,
            'warnings': self.warnings,
            'markdown_table': self.to_markdown()
        }


# ============================================================================
# I/O and Data Loading
# ============================================================================

class DataLoader:
    """Handles data loading and parsing"""

    @staticmethod
    def load_from_csv(csv_content: str) -> FitData:
        """Load data from CSV content"""
        try:
            data = pd.read_csv(io.StringIO(csv_content)).dropna()
            f_ghz = data.iloc[:, 0].values
            dk = data.iloc[:, 1].values
            df = data.iloc[:, 2].values
            complex_epsilon = dk - 1j * (dk * df)

            return FitData(
                f_ghz=f_ghz,
                complex_eps=complex_epsilon,
                measured_dk=dk.tolist(),
                measured_df=df.tolist()
            )
        except Exception as e:
            raise ValueError(f"Failed to parse CSV: {e}")


# ============================================================================
# Model and Physics
# ============================================================================

class DjordjevicSarkarModel:
    """Djordjevic-Sarkar dielectric model implementation"""

    @staticmethod
    def calculate(params: Dict[str, Any], f_ghz: np.ndarray) -> np.ndarray:
        """Calculate complex permittivity from model parameters"""
        omega = 2 * np.pi * f_ghz * 1e9

        # Extract real part of parameters (in case of complex-step)
        eps_inf = np.real(params['eps_inf'])
        delta_eps = np.real(params['delta_eps'])
        omega1 = np.real(params['omega1'])
        omega2 = np.real(params['omega2'])

        # Check if any parameter has imaginary part (complex-step)
        if any(np.iscomplex(params[k]) for k in params):
            # We're in complex-step mode, use complex arithmetic
            eps_inf = params['eps_inf']
            delta_eps = params['delta_eps']
            omega1 = params['omega1']
            omega2 = params['omega2']

        with np.errstate(divide='ignore', invalid='ignore'):
            if np.real(omega2) <= 0 or np.real(omega1) <= 0 or np.real(omega2) <= np.real(omega1):
                return np.full_like(f_ghz, np.nan, dtype=complex)

            log_term = np.log((omega2**2 + omega**2) / (omega1**2 + omega**2))
            eps_prime = eps_inf + (delta_eps / (2 * np.log(omega2 / omega1))) * log_term

            atan_term = np.arctan(omega / omega1) - np.arctan(omega / omega2)
            eps_double_prime = -(delta_eps / np.log(omega2 / omega1)) * atan_term

            return eps_prime + 1j * eps_double_prime

    @staticmethod
    def residual(params: Parameters, f_ghz: np.ndarray, complex_epsilon_data: np.ndarray) -> np.ndarray:
        """Calculate residuals for optimization"""
        p_dict = params.valuesdict()
        model_epsilon = DjordjevicSarkarModel.calculate(p_dict, f_ghz)

        real_residual = (np.real(model_epsilon) - np.real(complex_epsilon_data))
        imag_residual = (np.imag(model_epsilon) - np.imag(complex_epsilon_data))
        return np.concatenate([real_residual, imag_residual])

    @staticmethod
    def complex_step_jacobian(params_dict: Dict[str, float], f_ghz: np.ndarray, h: float = 1e-20) -> np.ndarray:
        """
        Calculate Jacobian using complex-step differentiation.
        This is numerically exact to machine precision for small h.
        """
        names = list(params_dict.keys())
        n = len(names)

        # Calculate base model
        base = DjordjevicSarkarModel.calculate(params_dict, f_ghz)
        base_vec = np.concatenate([base.real, base.imag])

        # Initialize Jacobian
        J = np.zeros((base_vec.size, n))

        # Calculate derivatives using complex step
        for i, name in enumerate(names):
            p2 = params_dict.copy()
            p2[name] += h * 1j  # Add imaginary perturbation

            # Calculate perturbed model
            y2 = DjordjevicSarkarModel.calculate(p2, f_ghz)
            vec2 = np.concatenate([y2.real, y2.imag])

            # Extract derivative from imaginary part
            J[:, i] = np.imag(vec2) / h

        return J

    @staticmethod
    def estimate_initial_parameters(fit_data: FitData, pct: float = 0.05) -> FitParameters:
        """
        Robust initial guess for model parameters.

        Args:
            fit_data: FitData object containing frequency and permittivity
            pct: fraction of points for averaging at ends
        """
        # Sort data by frequency
        idx = np.argsort(fit_data.f_ghz)
        f = fit_data.f_ghz[idx]
        eps = np.real(fit_data.complex_eps)[idx]
        df = np.imag(fit_data.complex_eps)[idx]

        n = len(f)
        k = max(1, int(n * pct))

        # Estimate parameters
        eps_s = np.mean(eps[:k])        # static permittivity at low freq
        eps_inf = np.mean(eps[-k:])     # high-freq permittivity
        delta_eps = max(eps_s - eps_inf, 1e-6)

        # Find loss peak
        peak_idx = np.argmax(np.abs(df))
        f_peak = f[peak_idx]

        f_low = max(f[0], f_peak / 10)
        f_high = min(f[-1], f_peak * 10)

        # Convert to rad/s
        omega1 = 2 * np.pi * f_low * 1e9
        omega2 = 2 * np.pi * f_high * 1e9

        # Safety check
        if omega2 <= omega1:
            omega2 = omega1 * 10

        return FitParameters(
            eps_inf=float(eps_inf),
            delta_eps=float(delta_eps),
            omega1=float(omega1),
            omega2=float(omega2)
        )


# ============================================================================
# Optimization
# ============================================================================

class Optimizer:
    """Handles the optimization process"""

    def __init__(self, fit_data: FitData):
        self.fit_data = fit_data

    def create_parameters(self, initial: FitParameters) -> Parameters:
        """Create lmfit Parameters object with bounds"""
        params = Parameters()
        dk_data = np.real(self.fit_data.complex_eps)

        params.add('eps_inf', value=initial.eps_inf, min=1.0, max=dk_data.max())
        params.add('delta_eps', value=initial.delta_eps, min=0, max=10)

        omega1_min = 2 * np.pi * 0.1e9
        omega2_max = 2 * np.pi * 1500e9

        params.add('omega1', value=initial.omega1, min=omega1_min, max=omega2_max)
        params.add('omega2', value=initial.omega2, min=omega1_min, max=omega2_max)

        return params

    def jacobian_wrapper(self, params: Parameters, f_ghz: np.ndarray, complex_eps: np.ndarray) -> np.ndarray:
        """Wrapper to use complex-step Jacobian with lmfit"""
        return DjordjevicSarkarModel.complex_step_jacobian(params.valuesdict(), f_ghz)

    def optimize(self, method: str = 'leastsq') -> Tuple[FitParameters, Any]:
        """Run optimization and return fitted parameters"""
        # Get initial guess
        initial = DjordjevicSarkarModel.estimate_initial_parameters(self.fit_data)

        # Create parameters
        params = self.create_parameters(initial)

        # Create minimizer with complex-step Jacobian
        minimizer = Minimizer(
            DjordjevicSarkarModel.residual,
            params,
            fcn_args=(self.fit_data.f_ghz, self.fit_data.complex_eps),
            Dfun=self.jacobian_wrapper,
            scale_covar=True
        )

        # Run optimization
        result = minimizer.minimize(method=method)

        # Extract fitted parameters
        fitted = FitParameters(
            eps_inf=float(result.params['eps_inf'].value),
            delta_eps=float(result.params['delta_eps'].value),
            omega1=float(result.params['omega1'].value),
            omega2=float(result.params['omega2'].value)
        )

        return fitted, result


# ============================================================================
# Evaluation and Reporting
# ============================================================================

class FitEvaluator:
    """Evaluates the quality of a fit report based on configurable metrics"""

    DEFAULT_THRESHOLDS: Dict[str, Tuple[float, float, float, str]] = {
        "reduced_chi_square": (1e-4, 1e-3, 1e-2, "Revisit noise model or add a relaxation term."),
        "rms_real": (0.005, 0.010, 0.020, "Loosen bounds or refine initial ε_inf/Δε."),
        "rms_imag": (0.001, 0.002, 0.005, "Add extra pole or use a hybrid model for loss plateau."),
        "mean_residual": (1e-4, 5e-4, 1e-3, "Check for systematic bias at low frequencies."),
    }

    DEFAULT_WEIGHTS: Dict[str, int] = {
        'dpv': 1,
        'reduced_chi_square': 3,
        'rms_real': 2,
        'rms_imag': 2,
        'mean_residual': 1,
        'correlation': 2
    }

    def __init__(self, thresholds=None, weights=None):
        self.thresholds = thresholds or FitEvaluator.DEFAULT_THRESHOLDS
        self.weights = weights or FitEvaluator.DEFAULT_WEIGHTS

    def evaluate_from_fit_result(self, fit_data: FitData, params: FitParameters, result: Any) -> ReportEvaluation:
        """Evaluate fit quality from optimization result"""
        # Calculate residuals
        model_epsilon = DjordjevicSarkarModel.calculate(params.to_dict(), fit_data.f_ghz)
        real_residuals = np.real(model_epsilon) - np.real(fit_data.complex_eps)
        imag_residuals = np.imag(model_epsilon) - np.imag(fit_data.complex_eps)

        # Build report data
        n_dat = len(real_residuals) + len(imag_residuals)
        n_var = 4
        chi_sqr = np.sum(real_residuals**2) + np.sum(imag_residuals**2)
        red_chi_sqr = chi_sqr / (n_dat - n_var) if (n_dat - n_var) > 0 else 0

        # Extract correlations from fit result
        correlations = {}
        if hasattr(result, 'var_names') and hasattr(result, 'covar') and result.covar is not None:
            for i, name1 in enumerate(result.var_names):
                for j, name2 in enumerate(result.var_names):
                    if j > i:
                        corr_val = result.covar[i, j] / np.sqrt(result.covar[i, i] * result.covar[j, j])
                        if abs(corr_val) > 0.1:
                            correlations[(name1, name2)] = corr_val

        report_data = {
            'n_data_points': n_dat,
            'n_variables': n_var,
            'reduced_chi_square': red_chi_sqr,
            'rms_real': float(np.sqrt(np.mean(real_residuals**2))),
            'rms_imag': float(np.sqrt(np.mean(imag_residuals**2))),
            'mean_real': float(np.mean(real_residuals)),
            'mean_imag': float(np.mean(imag_residuals)),
            'correlations': correlations
        }

        return self.evaluate(report_data)

    def evaluate(self, report: Dict[str, Any]) -> ReportEvaluation:
        """Validates and evaluates a fit report dictionary"""
        required = {
            'n_data_points', 'n_variables', 'reduced_chi_square',
            'rms_real', 'rms_imag', 'mean_real', 'mean_imag', 'correlations'
        }
        missing = required - report.keys()
        if missing:
            raise KeyError(f"Missing required report fields: {missing}")

        self._validate_report(report)
        warnings = self._validate_physical_bounds(report)

        metrics: Dict[str, MetricResult] = {}
        suggestions: List[str] = []

        mean_res = max(abs(report['mean_real']), abs(report['mean_imag']))
        report_vals = dict(report)
        report_vals['mean_residual'] = mean_res

        # Data-points-per-variable
        dpv = report['n_data_points'] / report['n_variables']
        dpv_score, dpv_cat = self._evaluate_inverse_scalar(dpv, (10, 20, 30))
        dpv_sug = "Collect more data or simplify model." if dpv_cat == "Poor" else None
        metrics['dpv'] = MetricResult('dpv', dpv_score, dpv_cat, dpv, dpv_sug)
        if dpv_sug:
            suggestions.append(dpv_sug)

        # Scalar metrics
        for name, (g, e, gd, sug) in self.thresholds.items():
            val = report_vals.get(name, 0)
            sc, cat = self._evaluate_scalar(val, (g, e, gd))
            sugg = sug if cat == "Poor" else None
            metrics[name] = MetricResult(name, sc, cat, val, sugg)
            if sugg:
                suggestions.append(sugg)

        # Correlation
        corrs = report['correlations']
        if not corrs:
            corr_score, corr_cat, corr_sug = 100, "Low", None
            worst_pair, worst_val = None, 0.0
        else:
            worst_pair, worst_val = max(corrs.items(), key=lambda kv: abs(kv[1]))
            corr_score, corr_cat, corr_sug = self._evaluate_correlation(worst_val)

        corr_result = MetricResult(
            'correlation', corr_score, corr_cat,
            worst_val, corr_sug, details={'pair': worst_pair}
        )
        metrics['correlation'] = corr_result
        if corr_sug:
            suggestions.append(corr_sug)

        # Overall score
        total_weight = sum(self.weights.values())
        overall_score = sum(
            metrics[k].score * self.weights.get(k, 1)
            for k in metrics.keys()
            if k in self.weights
        ) / total_weight

        if overall_score >= 90:
            overall_cat = "Godly"
        elif overall_score >= 75:
            overall_cat = "Excellent"
        elif overall_score >= 60:
            overall_cat = "Good"
        else:
            overall_cat = "Poor"

        overall = MetricResult("overall", round(overall_score, 1), overall_cat, round(overall_score, 1))
        return ReportEvaluation(metrics=metrics, overall=overall, suggestions=suggestions, warnings=warnings)

    def _validate_report(self, report: Dict[str, Any]) -> None:
        """Validate report data types and values"""
        try:
            n_data = int(report['n_data_points'])
            n_vars = int(report['n_variables'])
            if n_vars <= 0:
                raise ValueError("n_variables must be positive")
            if n_data <= n_vars:
                raise ValueError("n_data_points must exceed n_variables")
            numeric_fields = ['reduced_chi_square', 'rms_real', 'rms_imag', 'mean_real', 'mean_imag']
            for field in numeric_fields:
                val = report.get(field, 0)
                if not isinstance(val, (int, float)) or math.isnan(val):
                    raise ValueError(f"{field} must be a valid number")
        except (TypeError, ValueError, KeyError) as e:
            raise ValueError(f"Invalid report data: {e}")

    def _validate_physical_bounds(self, report: Dict[str, Any]) -> List[str]:
        """Check if values are physically reasonable"""
        warnings = []
        if report.get('rms_real', 0) > 1.0:
            warnings.append("RMS real part unusually high - check data quality")
        if report.get('rms_imag', 0) > 0.1:
            warnings.append("RMS imaginary part very high - check loss data quality")
        rcs = report.get('reduced_chi_square', 0)
        if rcs < 1e-6 and rcs > 0:
            warnings.append("Reduced chi-square suspiciously low - possible overfitting")
        elif rcs > 1.0:
            warnings.append("Reduced chi-square > 1 - model may be inadequate")
        if report.get('rms_real', 0) < 0 or report.get('rms_imag', 0) < 0:
            warnings.append("Negative RMS values detected - calculation error")
        return warnings

    def _evaluate_scalar(self, value: float, thresholds: Tuple[float, float, float]) -> Tuple[int, str]:
        """Evaluates metrics where smaller values are better"""
        godly_max, excellent_max, good_max = thresholds
        if value < godly_max:
            return 100, "Godly"
        elif value < excellent_max:
            return 80, "Excellent"
        elif value < good_max:
            return 60, "Good"
        return 30, "Poor"

    def _evaluate_inverse_scalar(self, value: float, thresholds: Tuple[float, float, float]) -> Tuple[int, str]:
        """Evaluates metrics where larger values are better"""
        poor_min, good_min, excellent_min = thresholds
        if value >= excellent_min:
            return 100, "Godly"
        elif value >= good_min:
            return 80, "Excellent"
        elif value >= poor_min:
            return 60, "Good"
        return 30, "Poor"

    def _evaluate_correlation(self, corr_value: float) -> Tuple[int, str, Optional[str]]:
        """Evaluates correlation, returning score, category, and suggestion"""
        if not isinstance(corr_value, (int, float)) or math.isnan(corr_value):
            return 30, "Invalid", "Check correlation calculation"
        abs_corr = abs(corr_value)
        if abs_corr < 0.50:
            return 100, "Low", None
        elif abs_corr < 0.80:
            return 80, "Moderate", None
        elif abs_corr < 0.95:
            return 60, "High", "Inspect uncertainties; consider fixing one parameter."
        return 30, "Very High", "Fix or remove one highly correlated parameter."


class ReportGenerator:
    """Generates formatted reports"""

    @staticmethod
    def generate_text_report(fit_data: FitData, params: FitParameters, result: Any, evaluation: Optional[ReportEvaluation] = None) -> str:
        """Generate a text report"""
        # Calculate statistics
        model_epsilon = DjordjevicSarkarModel.calculate(params.to_dict(), fit_data.f_ghz)
        real_residuals = np.real(model_epsilon) - np.real(fit_data.complex_eps)
        imag_residuals = np.imag(model_epsilon) - np.imag(fit_data.complex_eps)

        n_dat = len(real_residuals) + len(imag_residuals)
        n_var = 4
        chi_sqr = np.sum(real_residuals**2) + np.sum(imag_residuals**2)
        red_chi_sqr = chi_sqr / (n_dat - n_var) if (n_dat - n_var) > 0 else 0

        # Extract correlations
        correlations_str = ""
        if hasattr(result, 'var_names') and hasattr(result, 'covar') and result.covar is not None:
            correlations_str = "\\nCorrelations (from optimization):\\n"
            for i, name1 in enumerate(result.var_names):
                for j, name2 in enumerate(result.var_names):
                    if j > i and result.covar is not None:
                        corr_val = result.covar[i, j] / np.sqrt(result.covar[i, i] * result.covar[j, j])
                        if abs(corr_val) > 0.1:
                            correlations_str += f"    ({name1}, {name2}) = {corr_val:+.4f}\\n"

        report = f"""Djordjevic-Sarkar Fit Report
{'=' * 50}
Date: {datetime.now()}

Model and Parameters
--------------------------------------------------
ε'(ω) = ε_inf + (Δε / (2 * ln(ω₂/ω₁))) * ln((ω₂² + ω²) / (ω₁² + ω²))
ε''(ω) = -(Δε / ln(ω₂/ω₁)) * (atan(ω/ω₁) - atan(ω/ω₂))

Fitted parameters:
    eps_inf   = {params.eps_inf:.4f}
    delta_eps = {params.delta_eps:.4f}
    omega1    = {params.omega1:.4e} rad/s (f1 = {params.f1_ghz:.3f} GHz)
    omega2    = {params.omega2:.4e} rad/s (f2 = {params.f2_ghz:.3f} GHz)

Fit Statistics
    # data points = {n_dat}
    # variables   = {n_var}
    chi-square    = {chi_sqr:.4f}
    reduced chi-square = {red_chi_sqr:.4f}

Residual Analysis
    Real Part (Dk):
        Mean: {np.mean(real_residuals):.4f}
        Std Dev: {np.std(real_residuals):.4f}
        RMS: {np.sqrt(np.mean(real_residuals**2)):.4f}
    Imaginary Part (Loss Factor):
        Mean: {np.mean(imag_residuals):.4f}
        Std Dev: {np.std(imag_residuals):.4f}
        RMS: {np.sqrt(np.mean(imag_residuals**2)):.4f}

{correlations_str}"""

        if evaluation:
            report += f"\\n\\nFit Quality Evaluation\\n{'-' * 50}\\n"
            report += evaluation.to_markdown()

        return report

    @staticmethod
    def generate_json_report(fit_data: FitData, params: FitParameters, result: Any, evaluation: Optional[ReportEvaluation] = None) -> Dict[str, Any]:
        """Generate a JSON report"""
        # Calculate statistics
        model_epsilon = DjordjevicSarkarModel.calculate(params.to_dict(), fit_data.f_ghz)
        real_residuals = np.real(model_epsilon) - np.real(fit_data.complex_eps)
        imag_residuals = np.imag(model_epsilon) - np.imag(fit_data.complex_eps)

        n_dat = len(real_residuals) + len(imag_residuals)
        n_var = 4
        chi_sqr = np.sum(real_residuals**2) + np.sum(imag_residuals**2)
        red_chi_sqr = chi_sqr / (n_dat - n_var) if (n_dat - n_var) > 0 else 0

        # Extract correlation matrix
        corr_matrix = None
        if hasattr(result, 'var_names') and hasattr(result, 'covar') and result.covar is not None:
            n_params = len(result.var_names)
            corr_matrix = np.zeros((n_params, n_params))
            for i in range(n_params):
                for j in range(n_params):
                    if result.covar[i, i] > 0 and result.covar[j, j] > 0:
                        corr_matrix[i, j] = result.covar[i, j] / np.sqrt(result.covar[i, i] * result.covar[j, j])

        json_report = {
            "model": "Djordjevic-Sarkar",
            "timestamp": datetime.now().isoformat(),
            "parameters": {
                "eps_inf": params.eps_inf,
                "delta_eps": params.delta_eps,
                "omega1": params.omega1,
                "omega2": params.omega2,
                "f1_ghz": params.f1_ghz,
                "f2_ghz": params.f2_ghz
            },
            "fit_statistics": {
                "n_data_points": n_dat,
                "n_variables": n_var,
                "chi_square": chi_sqr,
                "reduced_chi_square": red_chi_sqr
            },
            "residual_analysis": {
                "real_part": {
                    "mean": float(np.mean(real_residuals)),
                    "std_dev": float(np.std(real_residuals)),
                    "rms": float(np.sqrt(np.mean(real_residuals**2)))
                },
                "imaginary_part": {
                    "mean": float(np.mean(imag_residuals)),
                    "std_dev": float(np.std(imag_residuals)),
                    "rms": float(np.sqrt(np.mean(imag_residuals**2)))
                }
            },
            "correlation_matrix": corr_matrix.tolist() if corr_matrix is not None else None
        }

        if evaluation:
            json_report['evaluation'] = evaluation.to_dict()

        return json_report


# ============================================================================
# Plotting
# ============================================================================

class Plotter:
    """Handles all plotting functionality"""

    @staticmethod
    def create_plotly_plot(fit_data: FitData, params: FitParameters) -> str:
        """Create interactive Plotly plot"""
        # Calculate fitted model
        fitted_epsilon = DjordjevicSarkarModel.calculate(params.to_dict(), fit_data.f_ghz)

        # Create subplots
        fig = make_subplots(rows=2, cols=1, subplot_titles=('Real Permittivity', 'Loss Tangent'))

        # Real part
        fig.add_trace(
            go.Scatter(
                x=fit_data.f_ghz,
                y=np.real(fit_data.complex_eps),
                mode='markers',
                name='Measured Dk',
                marker=dict(color='black')
            ),
            row=1, col=1
        )
        fig.add_trace(
            go.Scatter(
                x=fit_data.f_ghz,
                y=np.real(fitted_epsilon),
                mode='lines',
                name='Fitted Dk',
                line=dict(color='red')
            ),
            row=1, col=1
        )

        # Loss tangent
        measured_df = -np.imag(fit_data.complex_eps) / np.real(fit_data.complex_eps)
        fitted_df = -np.imag(fitted_epsilon) / np.real(fitted_epsilon)

        fig.add_trace(
            go.Scatter(
                x=fit_data.f_ghz,
                y=measured_df,
                mode='markers',
                name='Measured Df',
                marker=dict(color='black'),
                showlegend=False
            ),
            row=2, col=1
        )
        fig.add_trace(
            go.Scatter(
                x=fit_data.f_ghz,
                y=fitted_df,
                mode='lines',
                name='Fitted Df',
                line=dict(color='red'),
                showlegend=False
            ),
            row=2, col=1
        )

        # Update layout
        fig.update_xaxes(title_text="Frequency (GHz)", row=1, col=1)
        fig.update_yaxes(title_text="Dielectric Constant (Dk)", row=1, col=1)
        fig.update_xaxes(title_text="Frequency (GHz)", row=2, col=1)
        fig.update_yaxes(title_text="Dissipation Factor (Df)", row=2, col=1)

        fig.update_layout(
            height=600,
            margin=dict(l=20, r=20, t=40, b=20),
            template="plotly_white",
            legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99)
        )

        return pio.to_json(fig)

    @staticmethod
    def create_matplotlib_plot(fit_data: FitData, params: FitParameters) -> bytes:
        """Create downloadable matplotlib plot"""
        # Calculate fitted model
        fitted_epsilon = DjordjevicSarkarModel.calculate(params.to_dict(), fit_data.f_ghz)

        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 6))

        # Real part
        ax1.plot(fit_data.f_ghz, np.real(fit_data.complex_eps), 'ko', label='Measured')
        ax1.plot(fit_data.f_ghz, np.real(fitted_epsilon), 'r-', lw=2, label='Fitted')
        ax1.set_xlabel('Frequency (GHz)')
        ax1.set_ylabel('Dielectric Constant (Dk)')
        ax1.set_title('Real Permittivity')
        ax1.legend()
        ax1.grid(True, alpha=0.5)

        # Loss tangent
        measured_df = -np.imag(fit_data.complex_eps) / np.real(fit_data.complex_eps)
        fitted_df = -np.imag(fitted_epsilon) / np.real(fitted_epsilon)

        ax2.plot(fit_data.f_ghz, measured_df, 'ko', label='Measured')
        ax2.plot(fit_data.f_ghz, fitted_df, 'r-', lw=2, label='Fitted')
        ax2.set_xlabel('Frequency (GHz)')
        ax2.set_ylabel('Dissipation Factor (Df)')
        ax2.set_title('Loss Tangent')
        ax2.legend()
        ax2.grid(True, alpha=0.5)

        plt.tight_layout()

        # Save to bytes
        buf = io.BytesIO()
        plt.savefig(buf, format='png', dpi=150)
        plt.close(fig)
        buf.seek(0)
        return buf.getvalue()


# ============================================================================
# Main API Functions
# ============================================================================

class DjordjevicSarkarFitter:
    """Main class that orchestrates the fitting process"""

    def __init__(self):
        self.fit_data: Optional[FitData] = None
        self.current_params: Optional[FitParameters] = None
        self.last_result: Optional[Any] = None

    def load_data(self, csv_content: str) -> Dict[str, Any]:
        """Load data from CSV"""
        try:
            self.fit_data = DataLoader.load_from_csv(csv_content)
            return {
                "success": True,
                "message": "Data loaded successfully",
                "n_points": len(self.fit_data.f_ghz)
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }

    def run_analysis(self, method: str = 'leastsq') -> Dict[str, Any]:
        """Run the full analysis pipeline"""
        if self.fit_data is None:
            return {"error": "No data loaded"}

        try:
            # Run optimization
            optimizer = Optimizer(self.fit_data)
            self.current_params, self.last_result = optimizer.optimize(method)

            # Evaluate fit
            evaluator = FitEvaluator()
            evaluation = evaluator.evaluate_from_fit_result(
                self.fit_data,
                self.current_params,
                self.last_result
            )

            # Generate reports
            text_report = ReportGenerator.generate_text_report(
                self.fit_data,
                self.current_params,
                self.last_result,
                evaluation
            )
            json_report = ReportGenerator.generate_json_report(
                self.fit_data,
                self.current_params,
                self.last_result,
                evaluation
            )

            # Create plot
            plot_json = Plotter.create_plotly_plot(self.fit_data, self.current_params)

            return {
                "report": text_report,
                "json_data": json_report,
                "plot_json": plot_json,
                "fitted_params": self.current_params.to_dict(),
                "f_ghz": self.fit_data.f_ghz.tolist(),
                "measured_dk": self.fit_data.measured_dk,
                "measured_df": self.fit_data.measured_df
            }

        except Exception as e:
            logger.error(f"Analysis failed: {e}")
            return {"error": str(e)}

    def calculate_model_from_params(self, eps_inf: float, delta_eps: float,
                                   omega1: float, omega2: float) -> Dict[str, Any]:
        """Calculate model response for given parameters"""
        if self.fit_data is None:
            return {"error": "No data loaded"}

        params = {
            'eps_inf': eps_inf,
            'delta_eps': delta_eps,
            'omega1': omega1,
            'omega2': omega2
        }

        model_epsilon = DjordjevicSarkarModel.calculate(params, self.fit_data.f_ghz)

        return {
            "eps_prime": np.real(model_epsilon).tolist(),
            "eps_double_prime": np.imag(model_epsilon).tolist()
        }

    def create_updated_report(self, eps_inf: float, delta_eps: float,
                            omega1: float, omega2: float) -> Dict[str, Any]:
        """Create a report for manually adjusted parameters"""
        if self.fit_data is None:
            return {"error": "No data loaded"}

        # Create parameter object
        params = FitParameters(eps_inf, delta_eps, omega1, omega2)

        # Create a dummy result object for report generation
        class DummyResult:
            var_names = None
            covar = None

        dummy_result = DummyResult()

        # Generate reports
        text_report = ReportGenerator.generate_text_report(
            self.fit_data,
            params,
            dummy_result
        )
        json_report = ReportGenerator.generate_json_report(
            self.fit_data,
            params,
            dummy_result
        )

        return {
            "report": text_report,
            "json_data": json_report
        }

    def evaluate_current_fit(self, eps_inf: float, delta_eps: float,
                           omega1: float, omega2: float) -> Dict[str, Any]:
        """Evaluate the quality of current parameters"""
        if self.fit_data is None:
            return {"error": "No data loaded"}

        params = FitParameters(eps_inf, delta_eps, omega1, omega2)

        # Use last result if available, otherwise create dummy
        result = self.last_result if self.last_result is not None else type('obj', (object,), {'var_names': None, 'covar': None})

        # Evaluate
        evaluator = FitEvaluator()
        evaluation = evaluator.evaluate_from_fit_result(self.fit_data, params, result)

        # Generate JSON report
        json_report = ReportGenerator.generate_json_report(
            self.fit_data,
            params,
            result,
            evaluation
        )

        return json_report

    def create_downloadable_plot(self, eps_inf: float, delta_eps: float,
                               omega1: float, omega2: float) -> Optional[bytes]:
        """Create a downloadable PNG plot"""
        if self.fit_data is None:
            return None

        params = FitParameters(eps_inf, delta_eps, omega1, omega2)
        return Plotter.create_matplotlib_plot(self.fit_data, params)

    def get_measured_data(self) -> Dict[str, Any]:
        """Return the stored measured data"""
        if self.fit_data is None:
            return {
                "measured_dk": [],
                "measured_df": []
            }

        return {
            "measured_dk": self.fit_data.measured_dk,
            "measured_df": self.fit_data.measured_df
        }


# ============================================================================
# Wrapper functions for backward compatibility
# ============================================================================

# Create a global fitter instance
_fitter = DjordjevicSarkarFitter()

def load_data(csv_content: str) -> Tuple[np.ndarray, np.ndarray]:
    """Legacy wrapper for data loading"""
    result = _fitter.load_data(csv_content)
    if result.get("success"):
        return _fitter.fit_data.f_ghz, _fitter.fit_data.complex_eps
    else:
        raise ValueError(result.get("error", "Unknown error"))

def run_analysis(csv_content: str, method: str = 'leastsq') -> str:
    """Legacy wrapper for running analysis"""
    try:
        load_result = _fitter.load_data(csv_content)
        if not load_result.get("success"):
            return json.dumps({"error": load_result.get("error", "Failed to load data")})
        result = _fitter.run_analysis(method)
        return json.dumps(result)
    except Exception as e:
        return json.dumps({"error": str(e)})

def calculate_model_from_params(eps_inf: float, delta_eps: float,
                               omega1: float, omega2: float) -> str:
    """Legacy wrapper for model calculation"""
    result = _fitter.calculate_model_from_params(eps_inf, delta_eps, omega1, omega2)
    return json.dumps(result)

def create_updated_report(eps_inf: float, delta_eps: float,
                         omega1: float, omega2: float) -> str:
    """Legacy wrapper for report creation"""
    result = _fitter.create_updated_report(eps_inf, delta_eps, omega1, omega2)
    return json.dumps(result)

def evaluate_current_fit(eps_inf: float, delta_eps: float,
                        omega1: float, omega2: float) -> str:
    """Legacy wrapper for fit evaluation"""
    result = _fitter.evaluate_current_fit(eps_inf, delta_eps, omega1, omega2)
    return json.dumps(result)

def create_downloadable_plot(eps_inf: float, delta_eps: float,
                           omega1: float, omega2: float) -> Optional[bytes]:
    """Legacy wrapper for plot creation"""
    return _fitter.create_downloadable_plot(eps_inf, delta_eps, omega1, omega2)

def get_measured_data() -> str:
    """Legacy wrapper for getting measured data"""
    result = _fitter.get_measured_data()
    return json.dumps(result)

def estimate_initial_parameters(f_ghz: np.ndarray, complex_epsilon: np.ndarray, pct: float = 0.05) -> Dict[str, float]:
    """Legacy wrapper for initial parameter estimation"""
    fit_data = FitData(f_ghz, complex_epsilon)
    params = DjordjevicSarkarModel.estimate_initial_parameters(fit_data, pct)
    return params.to_dict()
`;

        async function main() {
            setLoadingState(true, 'Initializing Environment...');
            try {
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                setLoadingState(true, 'Loading Python Packages...');
                await pyodide.loadPackage(['numpy', 'pandas', 'micropip', 'matplotlib']);
                const micropip = pyodide.pyimport('micropip');
                setLoadingState(true, 'Installing lmfit & plotly...');
                await micropip.install(['lmfit', 'plotly']);
                isPyodideReady = true;
                await pyodide.runPythonAsync(pythonScript);
                setLoadingState(false);
            } catch (err) {
                isPyodideReady = false;
                showError(`Failed to initialize Python environment: ${err}`);
                setLoadingState(false);
            }
        }

        function setLoadingState(isLoading, message = '') {
            statusMessage.textContent = message;
            statusDiv.style.display = isLoading ? 'flex' : 'none';
            runButton.disabled = isLoading;
            runButton.classList.toggle('btn-disabled', isLoading);
            if (!isLoading) updateButtonState();
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
            outputDiv.classList.add('hidden');
        }

        function hideError() {
            errorBox.classList.add('hidden');
        }

        function updateButtonState() {
            const isReady = isPyodideReady && !!fileContent;
            runButton.disabled = !isReady;
            runButton.classList.toggle('btn-disabled', !isReady);
        }

        function setupParameterControls(params) {
            const twoPi = 2 * Math.PI;
            const f1_ghz = params.omega1 / (twoPi * 1e9);
            const f2_ghz = params.omega2 / (twoPi * 1e9);

            const uiParams = {
                eps_inf: params.eps_inf,
                delta_eps: params.delta_eps,
                omega1: f1_ghz,
                omega2: f2_ghz
            };
            
            const ranges = {
                eps_inf: { min: 1, max: Math.max(uiParams.eps_inf * 2, 10), step: 0.01 },
                delta_eps: { min: 0, max: Math.max(uiParams.delta_eps * 2, 5), step: 0.01 },
                omega1: { min: uiParams.omega1 / 10, max: uiParams.omega1 * 10, step: uiParams.omega1 / 100 },
                omega2: { min: uiParams.omega2 / 10, max: uiParams.omega2 * 10, step: uiParams.omega2 / 100 },
            };

            for (const key in uiParams) {
                if (paramControls[key]) {
                    const { slider, input } = paramControls[key];
                    const range = ranges[key];
                    
                    slider.min = range.min;
                    slider.max = range.max;
                    slider.step = range.step;
                    slider.value = uiParams[key];
                    
                    input.min = range.min;
                    input.max = range.max;
                    input.step = range.step;
                    input.value = uiParams[key];
                }
            }
        }

        async function updateUIFromControls() {
            if (!currentData || !pyodide) return;
            
            const eps_inf = parseFloat(paramControls.eps_inf.input.value);
            const delta_eps = parseFloat(paramControls.delta_eps.input.value);
            const f1_ghz = parseFloat(paramControls.omega1.input.value);
            const f2_ghz = parseFloat(paramControls.omega2.input.value);

            const twoPi = 2 * Math.PI;
            const omega1 = f1_ghz * twoPi * 1e9;
            const omega2 = f2_ghz * twoPi * 1e9;

            try {
                // Update Plot
                const calculateFunc = pyodide.globals.get('calculate_model_from_params');
                const modelJson = calculateFunc(eps_inf, delta_eps, omega1, omega2);
                const modelResults = JSON.parse(modelJson);
                
                if (modelResults.error) return;

                const fittedDk = modelResults.eps_prime;
                const fittedDf = fittedDk.map((dk, i) => -modelResults.eps_double_prime[i] / dk);
                Plotly.restyle('plot-output', { y: [fittedDk, fittedDf] }, [1, 3]);

                // Update Report with correlation matrix
                const generateReportFunc = pyodide.globals.get('create_updated_report');
                const reportJson = generateReportFunc(eps_inf, delta_eps, omega1, omega2);
                const reportData = JSON.parse(reportJson);
                reportOutput.textContent = reportData.report;
                
                // Update fit quality indicator
                const evaluateFunc = pyodide.globals.get('evaluate_current_fit');
                const evaluationJson = evaluateFunc(eps_inf, delta_eps, omega1, omega2);
                const evaluationData = JSON.parse(evaluationJson);
                
                if (evaluationData.evaluation) {
                    updateFitQualityIndicator(evaluationData.evaluation);
                }
                
            } catch (err) {
                console.error('Error updating UI:', err);
            }
        }
        
        function updateFitQualityIndicator(evaluation) {
            const indicator = document.getElementById('fit-quality-indicator');
            const scoreSpan = document.getElementById('fit-quality-score');
            const bar = document.getElementById('fit-quality-bar');
            
            if (!evaluation) {
                indicator.classList.add('hidden');
                return;
            }
            
            indicator.classList.remove('hidden');
            const score = evaluation.overall_score;
            const category = evaluation.overall_category;
            
            scoreSpan.textContent = `${score} (${category})`;
            
            // Update bar width and color
            bar.style.width = `${score}%`;
            
            if (score >= 90) {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-green-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-green-50 border border-green-200';
            } else if (score >= 75) {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-blue-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-blue-50 border border-blue-200';
            } else if (score >= 60) {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-yellow-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-yellow-50 border border-yellow-200';
            } else {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-red-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-red-50 border border-red-200';
            }
        }
        
        function resetParameters() {
            if (!currentData || !currentData.fitted_params) return;
            setupParameterControls(currentData.fitted_params);
            
            const plotData = JSON.parse(currentData.plot_json);
            Plotly.restyle('plot-output', {
                y: [plotData.data[1].y, plotData.data[3].y]
            }, [1, 3]);
            reportOutput.textContent = currentData.report;
            
            // Update fit quality for reset parameters
            const evaluateFunc = pyodide.globals.get('evaluate_current_fit');
            const params = currentData.fitted_params;
            const evaluationJson = evaluateFunc(params.eps_inf, params.delta_eps, params.omega1, params.omega2);
            const evaluationData = JSON.parse(evaluationJson);
            
            if (evaluationData.evaluation) {
                updateFitQualityIndicator(evaluationData.evaluation);
            }
        }

        async function downloadResults() {
            if (!currentData) return;
            setLoadingState(true, 'Preparing download...');
            try {
                const zip = new JSZip();
                const baseFilename = originalFilename.replace(/\.csv$/i, '');

                const eps_inf = parseFloat(paramControls.eps_inf.input.value);
                const delta_eps = parseFloat(paramControls.delta_eps.input.value);
                const f1_ghz = parseFloat(paramControls.omega1.input.value);
                const f2_ghz = parseFloat(paramControls.omega2.input.value);
                const twoPi = 2 * Math.PI;
                const omega1 = f1_ghz * twoPi * 1e9;
                const omega2 = f2_ghz * twoPi * 1e9;

                // 1. Create Fitted Data CSV from current slider values
                const calculateFunc = pyodide.globals.get('calculate_model_from_params');
                const modelJson = calculateFunc(eps_inf, delta_eps, omega1, omega2);
                const modelResults = JSON.parse(modelJson);
                
                let csvContent = "Frequency_GHz,fitted_Dk,fitted_Df\n";
                currentData.f_ghz.forEach((f, i) => {
                    const dk = modelResults.eps_prime[i];
                    const df = dk === 0 ? 0 : -modelResults.eps_double_prime[i] / dk;
                    csvContent += `${f},${dk},${df}\n`;
                });
                zip.file(`${baseFilename}_fitted.csv`, csvContent);

                // 2. Add Matplotlib Plot Image from current slider values
                const createPlotFunc = pyodide.globals.get('create_downloadable_plot');
                const imageProxy = createPlotFunc(eps_inf, delta_eps, omega1, omega2);
                const imageData = imageProxy.toJs();
                imageProxy.destroy();
                zip.file(`${baseFilename}_plot.png`, imageData);

                // 3. Add Report from current text content (human-readable .txt)
                zip.file(`${baseFilename}_report.txt`, reportOutput.textContent);

                // 4. Generate JSON report for database ingestion
                const generateReportFunc = pyodide.globals.get('create_updated_report');
                const reportJson = generateReportFunc(eps_inf, delta_eps, omega1, omega2);
                const reportData = JSON.parse(reportJson);
                
                // Get evaluation for current parameters
                const evaluateFunc = pyodide.globals.get('evaluate_current_fit');
                const evaluationJson = evaluateFunc(eps_inf, delta_eps, omega1, omega2);
                const evaluationData = JSON.parse(evaluationJson);
                
                // Get measured data from currentData
                let measuredDk = currentData.measured_dk || [];
                let measuredDf = currentData.measured_df || [];
                
                // Add additional fields to JSON
                const fullJsonReport = {
                    ...reportData.json_data,
                    input_file: originalFilename,
                    data: {
                        frequency_ghz: currentData.f_ghz,
                        measured: {
                            dk: measuredDk,
                            df: measuredDf
                        },
                        fitted: {
                            dk: modelResults.eps_prime,
                            df: modelResults.eps_prime.map((dk, i) => {
                                return dk === 0 ? 0 : -modelResults.eps_double_prime[i] / dk;
                            })
                        }
                    },
                    evaluation: evaluationData.evaluation
                };
                
                zip.file(`${baseFilename}_report.json`, JSON.stringify(fullJsonReport, null, 2));
                
                // 5. Add evaluation report as separate markdown file
                if (evaluationData.evaluation && evaluationData.evaluation.markdown_table) {
                    zip.file(`${baseFilename}_evaluation.md`, evaluationData.evaluation.markdown_table);
                }

                // 5. Generate and Download Zip
                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);
                link.download = `${baseFilename}_results.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch(err) {
                showError(`Failed to create download package: ${err}`);
            } finally {
                setLoadingState(false);
            }
        }

        // Set up event listeners
        let updateTimeout;
        Object.entries(paramControls).forEach(([key, { slider, input }]) => {
            slider.addEventListener('input', (e) => {
                input.value = e.target.value;
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(updateUIFromControls, 50);
            });
            
            input.addEventListener('input', (e) => {
                slider.value = e.target.value;
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(updateUIFromControls, 50);
            });
        });

        fileUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                originalFilename = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    fileContent = e.target.result;
                    updateButtonState();
                };
                reader.readAsText(file);
            } else {
                fileContent = null;
                originalFilename = '';
                updateButtonState();
            }
        });

        runButton.addEventListener('click', async () => {
            if (!fileContent || !pyodide) return;
            hideError();
            setLoadingState(true, 'Running analysis...');
            outputDiv.classList.add('hidden');

            try {
                const runAnalysis = pyodide.globals.get('run_analysis');
                const fitMethod = fitMethodSelect.value;
                const resultJson = runAnalysis(fileContent, fitMethod);
                const result = JSON.parse(resultJson);
                
                currentData = result;
                originalCorrelations = result.correlations;
                
                const plotData = JSON.parse(result.plot_json);
                plotOutput.innerHTML = '';
                Plotly.newPlot('plot-output', plotData.data, plotData.layout, {responsive: true});

                // Store measured data in currentData from the result
                currentData.measured_dk = result.measured_dk;
                currentData.measured_df = result.measured_df;

                reportOutput.textContent = result.report;
                setupParameterControls(result.fitted_params);
                
                // Show initial fit quality
                const evaluateFunc = pyodide.globals.get('evaluate_current_fit');
                const eps_inf = result.fitted_params.eps_inf;
                const delta_eps = result.fitted_params.delta_eps;
                const omega1 = result.fitted_params.omega1;
                const omega2 = result.fitted_params.omega2;
                
                const evaluationJson = evaluateFunc(eps_inf, delta_eps, omega1, omega2);
                const evaluationData = JSON.parse(evaluationJson);
                
                if (evaluationData.evaluation) {
                    updateFitQualityIndicator(evaluationData.evaluation);
                }
                
                outputDiv.classList.remove('hidden');

            } catch (err) {
                console.error(err);
                showError(`An error occurred during analysis: ${err.message}`);
            } finally {
                setLoadingState(false);
            }
        });
        
        resetButton.addEventListener('click', resetParameters);
        downloadButton.addEventListener('click', downloadResults);

        // Initialize
        main();
        updateButtonState();
    </script>
</body>
</html>