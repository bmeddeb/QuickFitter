<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hybrid Debye-Lorentz Model Fitter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .btn-disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Style for parameter sliders */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #d1d5db;
            border-radius: 3px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        .param-input {
            width: 80px;
            padding: 2px 4px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Interactive Hybrid Debye-Lorentz Model Fitter</h1>
            <p class="mt-2 text-lg text-gray-600">Upload your dielectric spectroscopy data (CSV) to fit it to the revised Hybrid Debye-Lorentz model with independent Debye and Lorentz mechanisms.</p>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
            <!-- Controls Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center mb-6">
                <div>
                    <label for="file-upload" class="block text-sm font-medium text-gray-700 mb-2">
                        Upload CSV File
                    </label>
                    <div class="flex items-center space-x-4">
                        <input type="file" id="file-upload" accept=".csv" class="block w-full text-sm text-gray-500
                            file:mr-4 file:py-2 file:px-4
                            file:rounded-lg file:border-0
                            file:text-sm file:font-semibold
                            file:bg-blue-50 file:text-blue-700
                            hover:file:bg-blue-100
                        ">
                    </div>
                     <p class="text-xs text-gray-500 mt-2">Expected columns: Frequency (GHz), Dk, Df</p>
                </div>
                <div class="space-y-4">
                    <div>
                        <label for="n-terms" class="block text-sm font-medium text-gray-700">Number of Terms (N)</label>
                        <select id="n-terms" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="1">1 term</option>
                            <option value="2" selected>2 terms</option>
                            <option value="3">3 terms</option>
                            <option value="4">4 terms</option>
                            <option value="5">5 terms</option>
                        </select>
                    </div>
                    <div>
                        <label for="fit-method" class="block text-sm font-medium text-gray-700">Optimization Method</label>
                        <select id="fit-method" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="least_squares" selected>least_squares (Default)</option>
                            <option value="nelder">nelder</option>
                            <option value="lbfgsb">lbfgsb</option>
                        </select>
                    </div>
                    <button id="run-button" class="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Run Analysis
                    </button>
                </div>
            </div>

            <!-- Status and Output Section -->
            <div id="status" class="text-center my-4 p-4 bg-gray-50 rounded-lg hidden">
                <div class="flex items-center justify-center">
                    <div class="spinner w-6 h-6 rounded-full border-4 border-gray-300"></div>
                    <p id="status-message" class="ml-4 text-gray-700 font-medium"></p>
                </div>
            </div>

            <div id="output" class="hidden mt-8">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- Plot Display -->
                    <div id="plot-container" class="lg:col-span-2 border border-gray-200 rounded-lg bg-gray-50 p-2">
                         <div id="plot-output"></div>
                    </div>

                    <!-- Parameters Display -->
                    <div id="params-panel" class="lg:col-span-1 bg-white p-6 rounded-lg border">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-gray-800">Adjust Parameters</h3>
                            <div class="flex space-x-2">
                                <button id="reset-button" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-1 px-3 rounded-lg">
                                    Reset
                                </button>
                                <button id="download-button" class="text-sm bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 px-3 rounded-lg">
                                    Download
                                </button>
                            </div>
                        </div>

                        <!-- Fit Quality Indicator -->
                        <div id="fit-quality-indicator" class="mb-4 p-3 rounded-lg hidden">
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium">Fit Quality:</span>
                                <span id="fit-quality-score" class="text-lg font-bold"></span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div id="fit-quality-bar" class="h-2 rounded-full transition-all duration-300"></div>
                            </div>
                        </div>

                        <div id="parameters-display" class="space-y-4 text-sm overflow-y-auto" style="max-height: 600px;">
                            <!-- Parameters will be dynamically inserted here -->
                        </div>
                    </div>
                </div>

                <!-- Report Display -->
                <div class="mt-8">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">Fit Report</h2>
                    <div class="bg-gray-900 text-white font-mono text-sm p-6 rounded-lg overflow-x-auto">
                        <pre id="report-output"></pre>
                    </div>
                </div>
            </div>
             <!-- Error Display -->
            <div id="error-box" class="hidden mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                <h3 class="font-bold">An Error Occurred</h3>
                <p id="error-message"></p>
            </div>
        </div>
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>Powered by Pyodide, lmfit, and the revised Hybrid Debye-Lorentz model (Rev. 2).</p>
        </footer>
    </div>

    <script type="text/javascript">
        // DOM Elements
        const fileUpload = document.getElementById('file-upload');
        const runButton = document.getElementById('run-button');
        const resetButton = document.getElementById('reset-button');
        const downloadButton = document.getElementById('download-button');
        const nTermsSelect = document.getElementById('n-terms');
        const fitMethodSelect = document.getElementById('fit-method');
        const statusDiv = document.getElementById('status');
        const statusMessage = document.getElementById('status-message');
        const outputDiv = document.getElementById('output');
        const plotOutput = document.getElementById('plot-output');
        const reportOutput = document.getElementById('report-output');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');
        const parametersDisplay = document.getElementById('parameters-display');

        // Global State
        let pyodide = null;
        let fileContent = null;
        let isPyodideReady = false;
        let currentData = null;
        let originalFilename = '';
        let paramControls = {};
        let originalParams = null;

        // Python Script with fixes for wide-range data
        const pythonScript = `
import sys
import io
import json
from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.io as pio
from lmfit import Minimizer, Parameters, fit_report
from scipy.signal import find_peaks
import math
import logging
from typing import Dict, Tuple, Any, List, Optional
from dataclasses import dataclass, field

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Fit Evaluator Classes (same as in Sarkar model)
@dataclass
class MetricResult:
    """Stores the evaluation result for a single metric."""
    name: str
    score: float
    category: str
    value: float
    suggestion: str | None = None
    details: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ReportEvaluation:
    """Stores the full evaluation for a report."""
    metrics: Dict[str, MetricResult]
    overall: MetricResult
    suggestions: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

    def to_markdown(self) -> str:
        """Return the evaluation as a markdown-formatted table."""
        headers = ["Metric", "Score", "Category", "Value", "Suggestion"]
        lines = ["| " + " | ".join(headers) + " |",
                 "| " + " | ".join(["---"]*len(headers)) + " |"]
        for m in self.metrics.values():
            suggestion = m.suggestion or ""
            lines.append(f"| {m.name} | {m.score} | {m.category} | {m.value:.4g} | {suggestion} |")
        lines.append(
            f"| **Overall** | {self.overall.score} | {self.overall.category} | {self.overall.value} |  |"
        )
        if self.warnings:
            lines.append("\\n**Warnings:**")
            for warning in self.warnings:
                lines.append(f"- {warning}")
        return "\\n".join(lines)

    def to_dict(self) -> Dict[str, Any]:
        """Convert evaluation to dictionary format."""
        return {
            'overall_score': self.overall.score,
            'overall_category': self.overall.category,
            'metrics': {
                k: {
                    'score': v.score,
                    'category': v.category,
                    'value': v.value,
                    'suggestion': v.suggestion,
                    'details': v.details
                }
                for k, v in self.metrics.items()
            },
            'suggestions': self.suggestions,
            'warnings': self.warnings,
            'markdown_table': self.to_markdown()
        }

class FitEvaluator:
    """Evaluates the quality of a fit report based on configurable metrics."""
    DEFAULT_THRESHOLDS: Dict[str, Tuple[float, float, float, str]] = {
        "reduced_chi_square": (0.8, 1.2, 2.0, "Check model order or data weighting."),
        "rms_real":           (0.005, 0.010, 0.020, "Try increasing number of terms or check initial parameters."),
        "rms_imag":           (0.001, 0.002, 0.005, "Add more Lorentz terms for better loss fitting."),
        "mean_residual":      (1e-4, 5e-4, 1e-3, "Check for systematic bias in the data."),
        "aic":                (50, 100, 200, "Consider simpler model or more data."),
        "bic":                (50, 100, 200, "Consider simpler model or more data."),
    }

    DEFAULT_WEIGHTS: Dict[str, int] = {
        'dpv': 1,
        'reduced_chi_square': 3,
        'rms_real': 2,
        'rms_imag': 2,
        'mean_residual': 1,
        'correlation': 2,
        'aic': 1,
        'bic': 1
    }

    def __init__(self, thresholds=None, weights=None):
        self.thresholds = thresholds or FitEvaluator.DEFAULT_THRESHOLDS
        self.weights = weights or FitEvaluator.DEFAULT_WEIGHTS

    @classmethod
    def from_json_report(cls, json_data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert JSON report format to evaluator format."""
        fit_stats = json_data.get('fit_statistics', {})
        residuals = json_data.get('residual_analysis', {})
        corr_matrix = json_data.get('correlation_matrix', [])
        correlations = {}
        if corr_matrix and isinstance(corr_matrix, list):
            # For hybrid model, we have more parameters
            n_params = len(corr_matrix)
            param_names = []
            n_terms = json_data.get('n_terms', 2)
            param_names.append('eps_inf')
            for i in range(n_terms):
                param_names.extend([f'delta_eps_D{i+1}', f'tau_D{i+1}', f'alpha{i+1}', f'delta_eps_L{i+1}', f'omega0{i+1}', f'gamma{i+1}'])

            try:
                for i in range(len(corr_matrix)):
                    for j in range(i+1, len(corr_matrix[0])):
                        if abs(corr_matrix[i][j]) > 0.1:
                            if i < len(param_names) and j < len(param_names):
                                correlations[(param_names[i], param_names[j])] = corr_matrix[i][j]
            except (IndexError, TypeError) as e:
                logger.warning(f"Error parsing correlation matrix: {e}")

        return {
            'n_data_points': fit_stats.get('n_data_points', 0),
            'n_variables': fit_stats.get('n_variables', 4),
            'reduced_chi_square': fit_stats.get('reduced_chi_square', 0),
            'rms_real': residuals.get('real_part', {}).get('rms', 0),
            'rms_imag': residuals.get('imaginary_part', {}).get('rms', 0),
            'mean_real': residuals.get('real_part', {}).get('mean', 0),
            'mean_imag': residuals.get('imaginary_part', {}).get('mean', 0),
            'correlations': correlations,
            'aic': fit_stats.get('aic', 0),
            'bic': fit_stats.get('bic', 0)
        }

    def _validate_report(self, report: Dict[str, Any]) -> None:
        """Validate report data types and values."""
        try:
            n_data = int(report['n_data_points'])
            n_vars = int(report['n_variables'])
            if n_vars <= 0:
                raise ValueError("n_variables must be positive")
            if n_data <= n_vars:
                raise ValueError("n_data_points must exceed n_variables")
            numeric_fields = ['reduced_chi_square', 'rms_real', 'rms_imag', 'mean_real', 'mean_imag', 'aic', 'bic']
            for field in numeric_fields:
                val = report.get(field, 0)
                if not isinstance(val, (int, float)) or math.isnan(val):
                    raise ValueError(f"{field} must be a valid number")
        except (TypeError, ValueError, KeyError) as e:
            raise ValueError(f"Invalid report data: {e}")

    def _validate_physical_bounds(self, report: Dict[str, Any]) -> List[str]:
        """Check if values are physically reasonable."""
        warnings = []
        if report.get('rms_real', 0) > 1.0:
            warnings.append("RMS real part unusually high - check data quality")
        if report.get('rms_imag', 0) > 0.1:
            warnings.append("RMS imaginary part very high - check loss data quality")
        rcs = report.get('reduced_chi_square', 0)
        if rcs < 1e-6 and rcs > 0:
            warnings.append("Reduced chi-square suspiciously low - possible overfitting")
        elif rcs > 1.0:
            warnings.append("Reduced chi-square > 1 - model may be inadequate")
        if report.get('rms_real', 0) < 0 or report.get('rms_imag', 0) < 0:
            warnings.append("Negative RMS values detected - calculation error")
        return warnings

    def _evaluate_scalar(self, value: float, thresholds: Tuple[float, float, float]) -> Tuple[int, str]:
        """Evaluates metrics where smaller values are better."""
        godly_max, excellent_max, good_max = thresholds
        if value < godly_max:
            return 100, "Godly"
        elif value < excellent_max:
            return 80, "Excellent"
        elif value < good_max:
            return 60, "Good"
        return 30, "Poor"

    def _evaluate_inverse_scalar(self, value: float, thresholds: Tuple[float, float, float]) -> Tuple[int, str]:
        """Evaluates metrics where larger values are better."""
        poor_min, good_min, excellent_min = thresholds
        if value >= excellent_min:
            return 100, "Godly"
        elif value >= good_min:
            return 80, "Excellent"
        elif value >= poor_min:
            return 60, "Good"
        return 30, "Poor"

    def _evaluate_correlation(self, corr_value: float) -> Tuple[int, str, str | None]:
        """Evaluates correlation, returning score, category, and suggestion."""
        if not isinstance(corr_value, (int, float)) or math.isnan(corr_value):
            return 30, "Invalid", "Check correlation calculation"
        abs_corr = abs(corr_value)
        if abs_corr < 0.50:
            return 100, "Low", None
        elif abs_corr < 0.80:
            return 80, "Moderate", None
        elif abs_corr < 0.95:
            return 60, "High", "Inspect uncertainties; consider fixing one parameter."
        return 30, "Very High", "Fix or remove one highly correlated parameter."

    def evaluate(self, report: Dict[str, Any]) -> ReportEvaluation:
        """Validates and evaluates a fit report dictionary."""
        required = {
            'n_data_points', 'n_variables', 'reduced_chi_square',
            'rms_real', 'rms_imag', 'mean_real', 'mean_imag', 'correlations',
            'aic', 'bic'
        }
        missing = required - report.keys()
        if missing:
            raise KeyError(f"Missing required report fields: {missing}")

        self._validate_report(report)
        warnings = self._validate_physical_bounds(report)

        metrics: Dict[str, MetricResult] = {}
        suggestions: List[str] = []

        mean_res = max(abs(report['mean_real']), abs(report['mean_imag']))
        report_vals = dict(report)
        report_vals['mean_residual'] = mean_res

        # Data-points-per-variable
        dpv = report['n_data_points'] / report['n_variables']
        dpv_score, dpv_cat = self._evaluate_inverse_scalar(dpv, (10, 20, 30))
        dpv_sug = "Collect more data or reduce number of terms." if dpv_cat == "Poor" else None
        metrics['dpv'] = MetricResult('dpv', dpv_score, dpv_cat, dpv, dpv_sug)
        if dpv_sug:
            suggestions.append(dpv_sug)

        # Scalar metrics
        for name, (g, e, gd, sug) in self.thresholds.items():
            val = report_vals.get(name, 0)
            sc, cat = self._evaluate_scalar(val, (g, e, gd))
            sugg = sug if cat == "Poor" else None
            metrics[name] = MetricResult(name, sc, cat, val, sugg)
            if sugg:
                suggestions.append(sugg)

        # Correlation
        corrs = report['correlations']
        if not corrs:
            corr_score, corr_cat, corr_sug = 100, "Low", None
            worst_pair, worst_val = None, 0.0
        else:
            worst_pair, worst_val = max(corrs.items(), key=lambda kv: abs(kv[1]))
            corr_score, corr_cat, corr_sug = self._evaluate_correlation(worst_val)

        corr_result = MetricResult(
            'correlation', corr_score, corr_cat,
            worst_val, corr_sug, details={'pair': worst_pair}
        )
        metrics['correlation'] = corr_result
        if corr_sug:
            suggestions.append(corr_sug)

        # Overall score
        total_weight = sum(self.weights.values())
        overall_score = sum(
            metrics[k].score * self.weights.get(k, 1)
            for k in metrics.keys()
            if k in self.weights
        ) / total_weight

        if overall_score >= 90:
            overall_cat = "Godly"
        elif overall_score >= 75:
            overall_cat = "Excellent"
        elif overall_score >= 60:
            overall_cat = "Good"
        else:
            overall_cat = "Poor"

        overall = MetricResult("overall", round(overall_score, 1), overall_cat, round(overall_score, 1))
        return ReportEvaluation(metrics=metrics, overall=overall, suggestions=suggestions, warnings=warnings)

# Global variables to store data
global_f_ghz = None
global_complex_epsilon = None
global_measured_dk = None
global_measured_df = None

def load_data(csv_content):
    global global_f_ghz, global_complex_epsilon, global_measured_dk, global_measured_df
    try:
        data = pd.read_csv(io.StringIO(csv_content)).dropna()
        f_ghz = data.iloc[:, 0].values
        dk = data.iloc[:, 1].values
        df = data.iloc[:, 2].values

        # Filter out invalid data points
        valid_mask = (dk > 0) & (df >= 0) & (df < 100)  # Basic validity checks
        f_ghz = f_ghz[valid_mask]
        dk = dk[valid_mask]
        df = df[valid_mask]

        complex_epsilon = dk - 1j * (dk * df)
        global_f_ghz = f_ghz
        global_complex_epsilon = complex_epsilon
        global_measured_dk = dk.tolist()
        global_measured_df = df.tolist()
        return f_ghz, complex_epsilon
    except Exception as e:
        raise ValueError(f"Failed to parse CSV: {e}")

def estimate_initial_parameters(f_ghz, complex_epsilon, n_terms):
    """Improved parameter estimation for wide-range data"""

    dk = np.real(complex_epsilon)
    df = -np.imag(complex_epsilon) / dk
    omega = 2 * np.pi * f_ghz * 1e9

    # Handle wide frequency range data
    f_min, f_max = f_ghz.min(), f_ghz.max()

    # Estimate eps_inf from high-frequency behavior
    # Use median of last 10% of data for robustness
    high_f_idx = int(len(dk) * 0.9)
    eps_inf = np.median(dk[high_f_idx:]) if len(dk) > 10 else dk[-1]
    eps_inf = max(1.0, eps_inf)  # Ensure positive

    # Detect peaks with adaptive parameters
    df_clean = np.nan_to_num(df, nan=0, posinf=0, neginf=0)
    min_prominence = 0.05 * np.nanmax(df_clean) if np.nanmax(df_clean) > 0 else 0.001

    peaks, properties = find_peaks(df_clean,
                                   prominence=min_prominence,
                                   width=1,
                                   distance=len(df_clean)//20)

    # If not enough peaks, distribute across frequency range
    if len(peaks) < n_terms:
        # Use log-spaced distribution for wide frequency ranges
        if f_max / f_min > 100:  # Wide range - use log spacing
            freq_points = np.logspace(np.log10(f_min + 1e-6), np.log10(f_max), n_terms)
        else:  # Narrow range - use linear spacing
            freq_points = np.linspace(f_min, f_max, n_terms)

        # Find closest actual data points
        peak_freqs = []
        for fp in freq_points:
            idx = np.argmin(np.abs(f_ghz - fp))
            peak_freqs.append(f_ghz[idx])
        peak_freqs = np.array(peak_freqs)
        peak_amps = np.interp(peak_freqs, f_ghz, df_clean)
    else:
        # Use detected peaks
        peak_freqs = f_ghz[peaks[:n_terms]]
        peak_amps = df_clean[peaks[:n_terms]]

    # Calculate initial parameters
    params = {'eps_inf': eps_inf}

    # Estimate total permittivity drop
    total_dk_drop = max(0.1, dk[0] - eps_inf) if len(dk) > 0 else 1.0

    for i in range(n_terms):
        term_num = i + 1

        # Frequency for this term
        if i < len(peak_freqs):
            f_peak = peak_freqs[i]
            amp = peak_amps[i] if i < len(peak_amps) else 0.01
        else:
            # Fallback distribution
            f_peak = f_min * (f_max / f_min) ** (i / max(n_terms - 1, 1))
            amp = 0.01

        # Ensure f_peak is valid
        f_peak = max(f_min, min(f_max, f_peak))

        # Calculate parameters with wide-range considerations
        omega0 = 2 * np.pi * f_peak * 1e9

        # Relaxation time - scale with frequency
        tau_D = 1 / (2 * np.pi * f_peak * 1e9)
        tau_D = np.clip(tau_D, 1e-15, 1e-6)

        # Amplitude allocation
        amp_ratio = 1.0 / n_terms  # Equal distribution as default
        delta_eps = total_dk_drop * amp_ratio
        delta_eps = max(0.01, delta_eps)  # Ensure positive

        # Alpha parameter - start near 0.8 for most materials
        alpha = 0.8

        # Gamma - scale with omega0
        gamma = omega0 / 20  # Q-factor of ~20 as starting point

        # Assign parameters
        params[f'delta_eps_D{term_num}'] = delta_eps * 0.6
        params[f'tau_D{term_num}'] = tau_D
        params[f'alpha{term_num}'] = alpha
        params[f'delta_eps_L{term_num}'] = delta_eps * 0.4
        params[f'omega0{term_num}'] = omega0
        params[f'gamma{term_num}'] = gamma

    return params

def calculate_hybrid_model(params, f_ghz, n_terms):
    """Calculate Hybrid Debye-Lorentz model response"""
    # Robust JsProxy to Python dict conversion
    if str(type(params)) == "<class 'pyodide.ffi.JsProxy'>":
        # Convert JsProxy to Python dict
        try:
            # Method 1: Try to_py() if available
            if hasattr(params, 'to_py'):
                params = params.to_py()
            else:
                # Method 2: Manual conversion using object_keys()
                param_dict = {}
                keys = params.object_keys()
                for key in keys:
                    param_dict[key] = params[key]
                params = param_dict
        except Exception as e:
            # Method 3: Fallback - extract values manually
            param_dict = {}
            # Try to get all expected parameter names
            param_dict['eps_inf'] = float(params['eps_inf']) if 'eps_inf' in params else 1.0
            for i in range(n_terms):
                param_dict[f'delta_eps_D{i+1}'] = float(params[f'delta_eps_D{i+1}']) if f'delta_eps_D{i+1}' in params else 0.1
                param_dict[f'tau_D{i+1}'] = float(params[f'tau_D{i+1}']) if f'tau_D{i+1}' in params else 1e-9
                param_dict[f'alpha{i+1}'] = float(params[f'alpha{i+1}']) if f'alpha{i+1}' in params else 0.8
                param_dict[f'delta_eps_L{i+1}'] = float(params[f'delta_eps_L{i+1}']) if f'delta_eps_L{i+1}' in params else 0.1
                param_dict[f'omega0{i+1}'] = float(params[f'omega0{i+1}']) if f'omega0{i+1}' in params else 1e10
                param_dict[f'gamma{i+1}'] = float(params[f'gamma{i+1}']) if f'gamma{i+1}' in params else 1e8
            params = param_dict

    # Ensure f_ghz is a numpy array
    f_ghz = np.asarray(f_ghz)
    omega = 2 * np.pi * f_ghz * 1e9

    eps_inf = float(params['eps_inf'])
    complex_epsilon = np.ones_like(omega, dtype=complex) * eps_inf

    for i in range(n_terms):
        # Extract new 6-parameter model parameters
        delta_D = float(params[f'delta_eps_D{i+1}'])
        tau_D = float(params[f'tau_D{i+1}'])
        alpha = float(params[f'alpha{i+1}'])
        delta_L = float(params[f'delta_eps_L{i+1}'])
        omega0 = float(params[f'omega0{i+1}'])
        gamma = float(params[f'gamma{i+1}'])

        # Independent Debye term with Cole-Cole modification
        debye = delta_D / (1 + (1j * omega * tau_D) ** alpha)

        # Independent Lorentz term with correct physical damping (2γω)
        lorentz = delta_L * omega0**2 / (omega0**2 - omega**2 - 1j * 2 * gamma * omega)

        # Add both terms independently (no fixed weighting)
        complex_epsilon += debye + lorentz

    return complex_epsilon

def residual(params, f_ghz, complex_epsilon_data, n_terms):
    p_dict = params.valuesdict()
    model_epsilon = calculate_hybrid_model(p_dict, f_ghz, n_terms)

    real_residual = (np.real(model_epsilon) - np.real(complex_epsilon_data))
    imag_residual = (np.imag(model_epsilon) - np.imag(complex_epsilon_data))

    # Dynamic residual weighting using data standard deviation
    sigma_r = np.std(np.real(complex_epsilon_data))
    sigma_i = np.std(np.imag(complex_epsilon_data))

    # Prevent division by zero
    sigma_r = max(sigma_r, 1e-10)
    sigma_i = max(sigma_i, 1e-10)

    return np.concatenate([real_residual / sigma_r, imag_residual / sigma_i])

def calculate_jacobian(params_dict, f_ghz, n_terms):
    """Calculate Jacobian matrix using finite differences with relative step"""
    param_names = ['eps_inf']
    for i in range(n_terms):
        param_names.extend([f'delta_eps_D{i+1}', f'tau_D{i+1}', f'alpha{i+1}', f'delta_eps_L{i+1}', f'omega0{i+1}', f'gamma{i+1}'])

    n_params = len(param_names)
    n_data = len(f_ghz) * 2  # real and imag parts

    jacobian = np.zeros((n_data, n_params))

    # Base model
    base_model = calculate_hybrid_model(params_dict, f_ghz, n_terms)
    base_residual = np.concatenate([np.real(base_model), np.imag(base_model)])

    # Calculate derivatives with robust step calculation to avoid machine precision issues
    eps = np.finfo(float).eps
    h_vec = np.array([eps**0.5 * max(abs(params_dict[param_name]), 1) for param_name in param_names])

    for i, param_name in enumerate(param_names):
        params_plus = params_dict.copy()
        step = h_vec[i]
        params_plus[param_name] += step

        model_plus = calculate_hybrid_model(params_plus, f_ghz, n_terms)
        residual_plus = np.concatenate([np.real(model_plus), np.imag(model_plus)])

        jacobian[:, i] = (residual_plus - base_residual) / step

    return jacobian

def calculate_correlation_matrix(params_dict, f_ghz, n_terms):
    """Calculate correlation matrix from Jacobian"""
    try:
        # Calculate Jacobian
        J = calculate_jacobian(params_dict, f_ghz, n_terms)

        # Calculate covariance matrix using eigenvalue clipping for robust regularization
        JTJ = np.dot(J.T, J)

        # Use eigenvalue clipping for regularization (robust to parameter scaling)
        s, U = np.linalg.eigh(JTJ)
        s_reg = np.clip(s, s.max() * 1e-8, None)
        cov_matrix = (U / s_reg) @ U.T

        # Convert to correlation matrix
        std_devs = np.sqrt(np.diag(cov_matrix))
        corr_matrix = np.zeros_like(cov_matrix)

        for i in range(len(std_devs)):
            for j in range(len(std_devs)):
                if std_devs[i] > 0 and std_devs[j] > 0:
                    corr_matrix[i, j] = cov_matrix[i, j] / (std_devs[i] * std_devs[j])
                else:
                    corr_matrix[i, j] = 0

        return corr_matrix
    except:
        return None

def format_correlation_matrix(corr_matrix, n_terms):
    """Format correlation matrix for display"""
    if corr_matrix is None:
        return "Unable to calculate correlation matrix"

    param_names = ['eps_inf']
    for i in range(n_terms):
        param_names.extend([f'delta_eps_D{i+1}', f'tau_D{i+1}', f'alpha{i+1}', f'delta_eps_L{i+1}', f'omega0{i+1}', f'gamma{i+1}'])

    result = "Correlations:\\n"

    for i, param1 in enumerate(param_names):
        for j, param2 in enumerate(param_names):
            if j > i:  # Only show upper triangle
                if i < len(corr_matrix) and j < len(corr_matrix):
                    correlation = corr_matrix[i, j]
                    if abs(correlation) > 0.1:  # Only show significant correlations
                        result += f"    ({param1}, {param2}) = {correlation:+.4f}\\n"

    return result

def create_plotly_plot(f_ghz, measured_eps, fitted_eps):
    fig = make_subplots(rows=2, cols=1, subplot_titles=('Real Permittivity', 'Loss Tangent'))
    fig.add_trace(go.Scatter(x=f_ghz, y=np.real(measured_eps), mode='markers', name='Measured Dk', marker=dict(color='black')), row=1, col=1)
    fig.add_trace(go.Scatter(x=f_ghz, y=np.real(fitted_eps), mode='lines', name='Fitted Dk', line=dict(color='red')), row=1, col=1)
    measured_df = -np.imag(measured_eps) / np.real(measured_eps)
    fitted_df = -np.imag(fitted_eps) / np.real(fitted_eps)

    # Clean up infinite values for plotting
    measured_df = np.nan_to_num(measured_df, nan=0, posinf=10, neginf=-10)
    fitted_df = np.nan_to_num(fitted_df, nan=0, posinf=10, neginf=-10)

    fig.add_trace(go.Scatter(x=f_ghz, y=measured_df, mode='markers', name='Measured Df', marker=dict(color='black'), showlegend=False), row=2, col=1)
    fig.add_trace(go.Scatter(x=f_ghz, y=fitted_df, mode='lines', name='Fitted Df', line=dict(color='red'), showlegend=False), row=2, col=1)
    fig.update_xaxes(title_text="Frequency (GHz)", row=1, col=1)
    fig.update_yaxes(title_text="Dielectric Constant (Dk)", row=1, col=1)
    fig.update_xaxes(title_text="Frequency (GHz)", row=2, col=1)
    fig.update_yaxes(title_text="Dissipation Factor (Df)", row=2, col=1)
    fig.update_layout(height=600, margin=dict(l=20, r=20, t=40, b=20), template="plotly_white", legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99))
    return pio.to_json(fig)

def create_downloadable_plot(fitted_params, n_terms):
    global global_f_ghz, global_complex_epsilon
    if global_f_ghz is None:
        return None

    # Robust JsProxy to Python dict conversion
    if str(type(fitted_params)) == "<class 'pyodide.ffi.JsProxy'>":
        try:
            if hasattr(fitted_params, 'to_py'):
                fitted_params = fitted_params.to_py()
            else:
                param_dict = {}
                keys = fitted_params.object_keys()
                for key in keys:
                    param_dict[key] = fitted_params[key]
                fitted_params = param_dict
        except Exception as e:
            # Fallback - extract values manually
            param_dict = {}
            param_dict['eps_inf'] = float(fitted_params['eps_inf']) if 'eps_inf' in fitted_params else 1.0
            for i in range(n_terms):
                param_dict[f'delta_eps_D{i+1}'] = float(fitted_params[f'delta_eps_D{i+1}']) if f'delta_eps_D{i+1}' in fitted_params else 0.1
                param_dict[f'tau_D{i+1}'] = float(fitted_params[f'tau_D{i+1}']) if f'tau_D{i+1}' in fitted_params else 1e-9
                param_dict[f'alpha{i+1}'] = float(fitted_params[f'alpha{i+1}']) if f'alpha{i+1}' in fitted_params else 0.8
                param_dict[f'delta_eps_L{i+1}'] = float(fitted_params[f'delta_eps_L{i+1}']) if f'delta_eps_L{i+1}' in fitted_params else 0.1
                param_dict[f'omega0{i+1}'] = float(fitted_params[f'omega0{i+1}']) if f'omega0{i+1}' in fitted_params else 1e10
                param_dict[f'gamma{i+1}'] = float(fitted_params[f'gamma{i+1}']) if f'gamma{i+1}' in fitted_params else 1e8
            fitted_params = param_dict
    fitted_epsilon = calculate_hybrid_model(fitted_params, global_f_ghz, n_terms)

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 6))

    ax1.plot(global_f_ghz, np.real(global_complex_epsilon), 'ko', label='Measured', markersize=2)
    ax1.plot(global_f_ghz, np.real(fitted_epsilon), 'r-', lw=2, label='Fitted')
    ax1.set_xlabel('Frequency (GHz)')
    ax1.set_ylabel('Dielectric Constant (Dk)')
    ax1.set_title('Real Permittivity')
    ax1.legend()
    ax1.grid(True, alpha=0.5)

    measured_df = -np.imag(global_complex_epsilon) / np.real(global_complex_epsilon)
    fitted_df = -np.imag(fitted_epsilon) / np.real(fitted_epsilon)

    # Clean up infinite values
    measured_df = np.nan_to_num(measured_df, nan=0, posinf=10, neginf=-10)
    fitted_df = np.nan_to_num(fitted_df, nan=0, posinf=10, neginf=-10)

    ax2.plot(global_f_ghz, measured_df, 'ko', label='Measured', markersize=2)
    ax2.plot(global_f_ghz, fitted_df, 'r-', lw=2, label='Fitted')
    ax2.set_xlabel('Frequency (GHz)')
    ax2.set_ylabel('Dissipation Factor (Df)')
    ax2.set_title('Loss Tangent')
    ax2.legend()
    ax2.grid(True, alpha=0.5)

    plt.tight_layout()

    buf = io.BytesIO()
    plt.savefig(buf, format='png', dpi=150)
    plt.close(fig)
    buf.seek(0)
    return buf.getvalue()

def run_analysis(csv_content, n_terms, method):
    global global_f_ghz, global_complex_epsilon
    f_ghz, complex_epsilon_data = load_data(csv_content)

    # Check if we have enough data
    if len(f_ghz) < n_terms * 6 + 1:
        raise ValueError(f"Insufficient data points ({len(f_ghz)}) for {n_terms} terms. Need at least {n_terms * 6 + 1} points.")

    initial_params = estimate_initial_parameters(f_ghz, complex_epsilon_data, n_terms)
    params = Parameters()

    # Add eps_inf with adaptive bounds
    dk_data = np.real(complex_epsilon_data)
    dk_min, dk_max = np.min(dk_data), np.max(dk_data)

    # Handle negative or zero values
    eps_inf_min = max(0.1, dk_min * 0.5) if dk_min > 0 else 0.1
    eps_inf_max = max(10, dk_max * 2)

    params.add('eps_inf',
               value=initial_params['eps_inf'],
               min=eps_inf_min,
               max=eps_inf_max)

    # Add parameters for each term with adaptive bounds
    f_min, f_max = f_ghz.min(), f_ghz.max()
    omega_min = 2 * np.pi * max(f_min, 1e-6) * 1e9
    omega_max = 2 * np.pi * f_max * 1e9

    for i in range(n_terms):
        # Delta parameters - ensure positive with reasonable bounds
        delta_D_init = max(0.01, initial_params[f'delta_eps_D{i+1}'])
        delta_L_init = max(0.01, initial_params[f'delta_eps_L{i+1}'])

        params.add(f'delta_eps_D{i+1}',
                   value=delta_D_init,
                   min=0,
                   max=max(10, abs(dk_max - dk_min) * 2))

        # Tau parameter with wide range for THz data
        tau_init = initial_params[f'tau_D{i+1}']
        params.add(f'tau_D{i+1}',
                   value=tau_init,
                   min=1e-15,
                   max=1e-3)  # Extended upper limit for low frequencies

        params.add(f'alpha{i+1}',
                   value=initial_params[f'alpha{i+1}'],
                   min=0.1,
                   max=1.0)

        params.add(f'delta_eps_L{i+1}',
                   value=delta_L_init,
                   min=0,
                   max=max(10, abs(dk_max - dk_min) * 2))

        # Omega0 with adaptive bounds
        omega0_init = initial_params[f'omega0{i+1}']
        omega0_init = np.clip(omega0_init, omega_min, omega_max)

        params.add(f'omega0{i+1}',
                   value=omega0_init,
                   min=omega_min * 0.1,  # Allow some flexibility
                   max=omega_max * 10)

        # Gamma with proper bounds
        gamma_init = initial_params[f'gamma{i+1}']
        gamma_min = omega0_init * 1e-4
        gamma_max = omega0_init
        gamma_init = np.clip(gamma_init, gamma_min * 1.1, gamma_max * 0.9)

        params.add(f'gamma{i+1}',
                   value=gamma_init,
                   min=gamma_min,
                   max=gamma_max)

    # Run minimization with error handling
    try:
        minimizer = Minimizer(residual, params, fcn_args=(f_ghz, complex_epsilon_data, n_terms))
        result = minimizer.minimize(method=method)
    except ValueError as e:
        # If initial values are infeasible, try with relaxed bounds
        logger.warning(f"Initial minimization failed: {e}. Trying with relaxed bounds.")

        # Reset parameters with more conservative initial values
        params = Parameters()
        params.add('eps_inf', value=np.median(dk_data), min=0.1, max=100)

        for i in range(n_terms):
            params.add(f'delta_eps_D{i+1}', value=0.5, min=0, max=100)
            params.add(f'tau_D{i+1}', value=1e-10, min=1e-15, max=1e-3)
            params.add(f'alpha{i+1}', value=0.8, min=0.1, max=1.0)
            params.add(f'delta_eps_L{i+1}', value=0.5, min=0, max=100)

            # Use mid-range frequency for omega0
            omega0_mid = (omega_min + omega_max) / 2
            params.add(f'omega0{i+1}', value=omega0_mid, min=omega_min * 0.01, max=omega_max * 100)
            params.add(f'gamma{i+1}', value=omega0_mid / 20, min=omega0_mid * 1e-5, max=omega0_mid)

        minimizer = Minimizer(residual, params, fcn_args=(f_ghz, complex_epsilon_data, n_terms))
        result = minimizer.minimize(method=method)

    fit_params = {p: float(v.value) for p, v in result.params.items()}

    # Use lmfit's correctly weighted statistical measures
    n_dat = len(f_ghz) * 2  # real and imag parts
    n_var = 1 + 6 * n_terms  # eps_inf + 6 params per term

    # Get properly weighted chi-square from lmfit result
    chi_sqr = result.chisqr if hasattr(result, 'chisqr') else 0.0
    red_chi_sqr = result.redchi if hasattr(result, 'redchi') else 0.0

    # Get AIC & BIC from lmfit result (properly calculated)
    aic = result.aic if hasattr(result, 'aic') else (n_dat * np.log(chi_sqr / n_dat) + 2 * n_var if chi_sqr > 0 else 0)
    bic = result.bic if hasattr(result, 'bic') else (n_dat * np.log(chi_sqr / n_dat) + n_var * np.log(n_dat) if chi_sqr > 0 else 0)

    # Calculate residuals for report display
    fitted_epsilon = calculate_hybrid_model(result.params.valuesdict(), f_ghz, n_terms)
    real_residuals = np.real(fitted_epsilon) - np.real(complex_epsilon_data)
    imag_residuals = np.imag(fitted_epsilon) - np.imag(complex_epsilon_data)

    # Calculate correlation matrix
    corr_matrix = calculate_correlation_matrix(result.params.valuesdict(), f_ghz, n_terms)
    corr_text = format_correlation_matrix(corr_matrix, n_terms)

    # Create model description
    model_desc = f"""Hybrid Debye-Lorentz Model with {n_terms} term(s)
--------------------------------------------------
 ε(ω) = ε_inf + Σ[i=1 to {n_terms}] H_i(ω)

where each hybrid term H_i combines independent Debye and Lorentz mechanisms:
H_i(ω) = Δε_D,i / (1 + (jωτ_D,i)^α_i) + Δε_L,i * ω_0,i² / (ω_0,i² - ω² - j2γ_i*ω)

with independent amplitudes and correct physical damping (2γω).
"""

    # Format parameters for report
    params_text = "Fitted Parameters:\\n"
    params_text += f"    eps_inf = {fit_params['eps_inf']:.4f}\\n"
    for i in range(n_terms):
        params_text += f"\\n    Term {i+1}:\\n"
        params_text += f"        delta_eps_D{i+1} = {fit_params[f'delta_eps_D{i+1}']:.4f}\\n"
        params_text += f"        tau_D{i+1}      = {fit_params[f'tau_D{i+1}']:.4e} s\\n"
        params_text += f"        alpha{i+1}      = {fit_params[f'alpha{i+1}']:.4f}\\n"
        params_text += f"        delta_eps_L{i+1} = {fit_params[f'delta_eps_L{i+1}']:.4f}\\n"
        params_text += f"        omega0{i+1}     = {fit_params[f'omega0{i+1}']:.4e} rad/s\\n"
        params_text += f"        gamma{i+1}      = {fit_params[f'gamma{i+1}']:.4e} rad/s\\n"

    # Create full report
    full_report = f"""Hybrid Debye-Lorentz Fit Report
{'=' * 50}
Date: {datetime.now()}
Frequency Range: {f_min:.2f} - {f_max:.2f} GHz

{model_desc}

{params_text}

Fit Statistics
--------------------------------------------------
    # data points      = {n_dat}
    # variables        = {n_var}
    chi-square         = {chi_sqr:.4f}
    reduced chi-square = {red_chi_sqr:.4f}
    AIC                = {aic:.2f}
    BIC                = {bic:.2f}

Residual Analysis
--------------------------------------------------
    Real Part (Dk):
        Mean: {np.mean(real_residuals):.4f}
        Std Dev: {np.std(real_residuals):.4f}
        RMS: {np.sqrt(np.mean(real_residuals**2)):.4f}

    Imaginary Part (Loss Factor):
        Mean: {np.mean(imag_residuals):.4f}
        Std Dev: {np.std(imag_residuals):.4f}
        RMS: {np.sqrt(np.mean(imag_residuals**2)):.4f}

{corr_text}

Optimization Details
--------------------------------------------------
Method: {method}
Success: {result.success}
Message: {result.message}
"""

    # Create JSON data structure
    json_data = {
        "model": "Hybrid Debye-Lorentz",
        "n_terms": n_terms,
        "timestamp": datetime.now().isoformat(),
        "parameters": fit_params,
        "fit_statistics": {
            "n_data_points": n_dat,
            "n_variables": n_var,
            "chi_square": chi_sqr,
            "reduced_chi_square": red_chi_sqr,
            "aic": aic,
            "bic": bic
        },
        "residual_analysis": {
            "real_part": {
                "mean": float(np.mean(real_residuals)),
                "std_dev": float(np.std(real_residuals)),
                "rms": float(np.sqrt(np.mean(real_residuals**2)))
            },
            "imaginary_part": {
                "mean": float(np.mean(imag_residuals)),
                "std_dev": float(np.std(imag_residuals)),
                "rms": float(np.sqrt(np.mean(imag_residuals**2)))
            }
        },
        "correlation_matrix": corr_matrix.tolist() if corr_matrix is not None else None
    }

    # Evaluate the fit
    try:
        evaluator = FitEvaluator()
        report_data = FitEvaluator.from_json_report(json_data)
        evaluation = evaluator.evaluate(report_data)
        json_data['evaluation'] = evaluation.to_dict()
    except Exception as e:
        logger.warning(f"Could not evaluate fit: {e}")
        json_data['evaluation'] = None

    plot_json = create_plotly_plot(f_ghz, complex_epsilon_data, fitted_epsilon)

    return_data = {
        "report": full_report,
        "plot_json": plot_json,
        "f_ghz": f_ghz.tolist(),
        "fitted_params": fit_params,
        "json_data": json_data,
        "n_terms": n_terms,
        "measured_dk": global_measured_dk,
        "measured_df": global_measured_df
    }
    return json.dumps(return_data)
`;

        async function main() {
            setLoadingState(true, 'Initializing Environment...');
            try {
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                setLoadingState(true, 'Loading Python Packages...');
                await pyodide.loadPackage(['numpy', 'pandas', 'micropip', 'matplotlib']);
                const micropip = pyodide.pyimport('micropip');
                setLoadingState(true, 'Installing lmfit & plotly...');
                await micropip.install(['lmfit', 'plotly']);
                isPyodideReady = true;
                await pyodide.runPythonAsync(pythonScript);
                setLoadingState(false);
            } catch (err) {
                isPyodideReady = false;
                showError(`Failed to initialize Python environment: ${err}`);
                setLoadingState(false);
            }
        }

        function setLoadingState(isLoading, message = '') {
            statusMessage.textContent = message;
            statusDiv.style.display = isLoading ? 'flex' : 'none';
            runButton.disabled = isLoading;
            runButton.classList.toggle('btn-disabled', isLoading);
            if (!isLoading) updateButtonState();
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
            outputDiv.classList.add('hidden');
        }

        function hideError() {
            errorBox.classList.add('hidden');
        }

        function updateButtonState() {
            const isReady = isPyodideReady && !!fileContent;
            runButton.disabled = !isReady;
            runButton.classList.toggle('btn-disabled', !isReady);
        }

        function displayParameters(params, n_terms) {
            parametersDisplay.innerHTML = '';
            paramControls = {};

            // eps_inf
            const epsInfDiv = document.createElement('div');
            epsInfDiv.className = 'pb-3 border-b border-gray-200';
            epsInfDiv.innerHTML = `
                <div class="font-medium mb-2">ε<sub>∞</sub> (Epsilon Infinity)</div>
                <div class="space-y-1">
                    <input type="range" id="eps_inf_slider" class="w-full">
                    <div class="flex items-center justify-between">
                        <input type="number" id="eps_inf_input" class="param-input" step="0.01">
                        <span class="text-xs text-gray-500">Range: <span id="eps_inf_range"></span></span>
                    </div>
                </div>
            `;
            parametersDisplay.appendChild(epsInfDiv);

            paramControls['eps_inf'] = {
                slider: epsInfDiv.querySelector('#eps_inf_slider'),
                input: epsInfDiv.querySelector('#eps_inf_input'),
                rangeSpan: epsInfDiv.querySelector('#eps_inf_range')
            };

            // Terms
            for (let i = 0; i < n_terms; i++) {
                const termDiv = document.createElement('div');
                termDiv.className = 'pt-3 pb-3 border-b border-gray-200';
                termDiv.innerHTML = `
                    <div class="font-medium mb-2">Term ${i + 1}</div>
                    <div class="space-y-2">
                        <!-- Debye delta_eps parameter -->
                        <div>
                            <div class="text-xs text-gray-600 mb-1">Δε<sub>D,${i+1}</sub> (Debye strength)</div>
                            <input type="range" id="delta_eps_D${i+1}_slider" class="w-full">
                            <div class="flex items-center justify-between">
                                <input type="number" id="delta_eps_D${i+1}_input" class="param-input" step="0.01">
                                <span class="text-xs text-gray-500">Range: <span id="delta_eps_D${i+1}_range"></span></span>
                            </div>
                        </div>
                        <!-- Debye tau parameter -->
                        <div>
                            <div class="text-xs text-gray-600 mb-1">τ<sub>D,${i+1}</sub> (Debye relaxation time, s)</div>
                            <input type="range" id="tau_D${i+1}_slider" class="w-full">
                            <div class="flex items-center justify-between">
                                <input type="number" id="tau_D${i+1}_input" class="param-input" step="1e-14">
                                <span class="text-xs text-gray-500">Range: <span id="tau_D${i+1}_range"></span></span>
                            </div>
                        </div>
                        <!-- alpha parameter -->
                        <div>
                            <div class="text-xs text-gray-600 mb-1">α<sub>${i+1}</sub> (Cole-Cole parameter)</div>
                            <input type="range" id="alpha${i+1}_slider" class="w-full">
                            <div class="flex items-center justify-between">
                                <input type="number" id="alpha${i+1}_input" class="param-input" step="0.01">
                                <span class="text-xs text-gray-500">Range: <span id="alpha${i+1}_range"></span></span>
                            </div>
                        </div>
                        <!-- Lorentz delta_eps parameter -->
                        <div>
                            <div class="text-xs text-gray-600 mb-1">Δε<sub>L,${i+1}</sub> (Lorentz strength)</div>
                            <input type="range" id="delta_eps_L${i+1}_slider" class="w-full">
                            <div class="flex items-center justify-between">
                                <input type="number" id="delta_eps_L${i+1}_input" class="param-input" step="0.01">
                                <span class="text-xs text-gray-500">Range: <span id="delta_eps_L${i+1}_range"></span></span>
                            </div>
                        </div>
                        <!-- omega0 parameter -->
                        <div>
                            <div class="text-xs text-gray-600 mb-1">ω<sub>0,${i+1}</sub> (Resonance frequency, rad/s)</div>
                            <input type="range" id="omega0${i+1}_slider" class="w-full">
                            <div class="flex items-center justify-between">
                                <input type="number" id="omega0${i+1}_input" class="param-input" step="1e7">
                                <span class="text-xs text-gray-500">Range: <span id="omega0${i+1}_range"></span></span>
                            </div>
                        </div>
                        <!-- gamma parameter -->
                        <div>
                            <div class="text-xs text-gray-600 mb-1">γ<sub>${i+1}</sub> (Damping parameter, rad/s)</div>
                            <input type="range" id="gamma${i+1}_slider" class="w-full">
                            <div class="flex items-center justify-between">
                                <input type="number" id="gamma${i+1}_input" class="param-input" step="1e7">
                                <span class="text-xs text-gray-500">Range: <span id="gamma${i+1}_range"></span></span>
                            </div>
                        </div>
                    </div>
                `;
                parametersDisplay.appendChild(termDiv);

                // Add controls for this term
                const termParams = ['delta_eps_D', 'tau_D', 'alpha', 'delta_eps_L', 'omega0', 'gamma'];
                termParams.forEach(param => {
                    const key = `${param}${i+1}`;
                    paramControls[key] = {
                        slider: termDiv.querySelector(`#${key}_slider`),
                        input: termDiv.querySelector(`#${key}_input`),
                        rangeSpan: termDiv.querySelector(`#${key}_range`)
                    };
                });
            }

            // Set up controls with values and ranges
            setupParameterControls(params, n_terms);
        }

        function setupParameterControls(params, n_terms) {
            // Store original parameters for reset
            originalParams = {...params};

            // Set up eps_inf
            const eps_inf_val = params.eps_inf;
            const eps_inf_range = {
                min: Math.max(0.5, eps_inf_val * 0.5),
                max: Math.min(10, eps_inf_val * 2),
                step: 0.01
            };

            setControlValues('eps_inf', eps_inf_val, eps_inf_range);

            // Set up term parameters
            for (let i = 0; i < n_terms; i++) {
                // delta_eps_D parameter
                const delta_eps_D_val = params[`delta_eps_D${i+1}`];
                const delta_eps_D_range = {
                    min: 0,
                    max: Math.max(10, delta_eps_D_val * 3),
                    step: 0.01
                };
                setControlValues(`delta_eps_D${i+1}`, delta_eps_D_val, delta_eps_D_range);

                // tau_D parameter (logarithmic scale)
                const tau_D_val = params[`tau_D${i+1}`];
                const tau_D_range = {
                    min: 1e-15,
                    max: 1e-6,
                    step: 1e-15,
                    logScale: true
                };
                setControlValues(`tau_D${i+1}`, tau_D_val, tau_D_range);

                // alpha parameter
                const alpha_val = params[`alpha${i+1}`];
                const alpha_range = {
                    min: 0.1,
                    max: 1.0,
                    step: 0.01
                };
                setControlValues(`alpha${i+1}`, alpha_val, alpha_range);

                // delta_eps_L parameter
                const delta_eps_L_val = params[`delta_eps_L${i+1}`];
                const delta_eps_L_range = {
                    min: 0,
                    max: Math.max(10, delta_eps_L_val * 3),
                    step: 0.01
                };
                setControlValues(`delta_eps_L${i+1}`, delta_eps_L_val, delta_eps_L_range);

                // omega0 parameter (logarithmic scale)
                const omega0_val = params[`omega0${i+1}`];
                const omega0_range = {
                    min: 1e7,
                    max: 1e12,
                    step: 1e7,
                    logScale: true
                };
                setControlValues(`omega0${i+1}`, omega0_val, omega0_range);

                // gamma parameter (logarithmic scale)
                const gamma_val = params[`gamma${i+1}`];
                const gamma_range = {
                    min: 1e7,
                    max: 1e12,
                    step: 1e7,
                    logScale: true
                };
                setControlValues(`gamma${i+1}`, gamma_val, gamma_range);
            }

            // Add event listeners
            setupEventListeners(n_terms);
        }

        function setControlValues(paramName, value, range) {
            const control = paramControls[paramName];
            if (!control) return;

            const { slider, input, rangeSpan } = control;

            if (range.logScale) {
                // For logarithmic parameters like tau
                const logMin = Math.log10(range.min);
                const logMax = Math.log10(range.max);
                const logValue = Math.log10(value);

                slider.min = 0;
                slider.max = 100;
                slider.value = ((logValue - logMin) / (logMax - logMin)) * 100;

                input.value = value.toExponential(2);
                input.step = range.step;
                rangeSpan.textContent = `${range.min.toExponential(0)} - ${range.max.toExponential(0)}`;
            } else {
                slider.min = range.min;
                slider.max = range.max;
                slider.step = range.step;
                slider.value = value;

                input.min = range.min;
                input.max = range.max;
                input.step = range.step;
                input.value = value;

                rangeSpan.textContent = `${range.min.toFixed(2)} - ${range.max.toFixed(2)}`;
            }
        }



        function setupEventListeners(n_terms) {
            let updateTimeout;

            // eps_inf listeners
            const epsInfControl = paramControls['eps_inf'];
            if (epsInfControl) {
                epsInfControl.slider.addEventListener('input', (e) => {
                    epsInfControl.input.value = e.target.value;
                    clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                });

                epsInfControl.input.addEventListener('input', (e) => {
                    epsInfControl.slider.value = e.target.value;
                    clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                });
            }

            // Term parameter listeners
            for (let i = 0; i < n_terms; i++) {
                // Regular parameters (delta_eps_D, alpha, delta_eps_L)
                ['delta_eps_D', 'alpha', 'delta_eps_L'].forEach(param => {
                    const key = `${param}${i+1}`;
                    const control = paramControls[key];
                    if (control) {
                        control.slider.addEventListener('input', (e) => {
                            control.input.value = e.target.value;
                            clearTimeout(updateTimeout);
                            updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                        });

                        control.input.addEventListener('input', (e) => {
                            control.slider.value = e.target.value;
                            clearTimeout(updateTimeout);
                            updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                        });
                    }
                });

                // tau_D parameter (logarithmic)
                const tauDControl = paramControls[`tau_D${i+1}`];
                if (tauDControl) {
                    tauDControl.slider.addEventListener('input', (e) => {
                        const logMin = Math.log10(1e-15);
                        const logMax = Math.log10(1e-6);
                        const logValue = logMin + (e.target.value / 100) * (logMax - logMin);
                        const value = Math.pow(10, logValue);
                        tauDControl.input.value = value.toExponential(2);
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                    });

                    tauDControl.input.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        const logMin = Math.log10(1e-15);
                        const logMax = Math.log10(1e-6);
                        const logValue = Math.log10(value);
                        tauDControl.slider.value = ((logValue - logMin) / (logMax - logMin)) * 100;
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                    });
                }

                // omega0 parameter (logarithmic)
                const omega0Control = paramControls[`omega0${i+1}`];
                if (omega0Control) {
                    omega0Control.slider.addEventListener('input', (e) => {
                        const logMin = Math.log10(1e7);
                        const logMax = Math.log10(1e12);
                        const logValue = logMin + (e.target.value / 100) * (logMax - logMin);
                        const value = Math.pow(10, logValue);
                        omega0Control.input.value = value.toExponential(2);
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                    });

                    omega0Control.input.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        const logMin = Math.log10(1e7);
                        const logMax = Math.log10(1e12);
                        const logValue = Math.log10(value);
                        omega0Control.slider.value = ((logValue - logMin) / (logMax - logMin)) * 100;
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                    });
                }

                // gamma parameter (logarithmic)
                const gammaControl = paramControls[`gamma${i+1}`];
                if (gammaControl) {
                    gammaControl.slider.addEventListener('input', (e) => {
                        const logMin = Math.log10(1e7);
                        const logMax = Math.log10(1e12);
                        const logValue = logMin + (e.target.value / 100) * (logMax - logMin);
                        const value = Math.pow(10, logValue);
                        gammaControl.input.value = value.toExponential(2);
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                    });

                    gammaControl.input.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        const logMin = Math.log10(1e7);
                        const logMax = Math.log10(1e12);
                        const logValue = Math.log10(value);
                        gammaControl.slider.value = ((logValue - logMin) / (logMax - logMin)) * 100;
                        clearTimeout(updateTimeout);
                        updateTimeout = setTimeout(() => updateUIFromControls(n_terms), 50);
                    });
                }
            }
        }

        async function updateUIFromControls(n_terms) {
            if (!currentData || !pyodide) return;

            // Gather current parameter values
            const params = {
                eps_inf: parseFloat(paramControls['eps_inf'].input.value)
            };

            for (let i = 0; i < n_terms; i++) {
                params[`delta_eps_D${i+1}`] = parseFloat(paramControls[`delta_eps_D${i+1}`].input.value);
                params[`tau_D${i+1}`] = parseFloat(paramControls[`tau_D${i+1}`].input.value);
                params[`alpha${i+1}`] = parseFloat(paramControls[`alpha${i+1}`].input.value);
                params[`delta_eps_L${i+1}`] = parseFloat(paramControls[`delta_eps_L${i+1}`].input.value);
                params[`omega0${i+1}`] = parseFloat(paramControls[`omega0${i+1}`].input.value);
                params[`gamma${i+1}`] = parseFloat(paramControls[`gamma${i+1}`].input.value);
            }

            // Initialize proxy variables for cleanup
            let pyParams = null;
            let pyFGhz = null;
            let modelProxy = null;

            try {
                // Update Plot
                const calculateFunc = pyodide.globals.get('calculate_hybrid_model');
                // Convert params to Python dict using pyodide
                pyParams = pyodide.toPy(params);
                pyFGhz = pyodide.toPy(currentData.f_ghz);
                modelProxy = calculateFunc(pyParams, pyFGhz, n_terms);

                // Convert complex array properly
                const real = pyodide.globals.get('np').real(modelProxy).toJs();
                const imag = pyodide.globals.get('np').imag(modelProxy).toJs();

                const fittedDk = real;
                const fittedDf = fittedDk.map((dk, i) => dk === 0 ? 0 : -imag[i] / dk);

                Plotly.restyle('plot-output', { y: [fittedDk, fittedDf] }, [1, 3]);

                // Update Report
                const real_residuals = fittedDk.map((dk, i) => dk - currentData.measured_dk[i]);
                const imag_residuals = fittedDf.map((df, i) => df - currentData.measured_df[i]);

                const n_dat = real_residuals.length * 2;
                const n_var = 1 + 6 * n_terms;

                // Use weighted residuals for chi-square (consistent with Python residual() function)
                const sigma_r = Math.sqrt(currentData.measured_dk.reduce((sum, val, i, arr) => {
                    const mean = arr.reduce((s, v) => s + v, 0) / arr.length;
                    return sum + (val - mean) ** 2;
                }, 0) / currentData.measured_dk.length);

                const sigma_i = Math.sqrt(currentData.measured_df.reduce((sum, val, i, arr) => {
                    const mean = arr.reduce((s, v) => s + v, 0) / arr.length;
                    return sum + (val - mean) ** 2;
                }, 0) / currentData.measured_df.length);

                const chi_sqr = real_residuals.reduce((sum, r) => sum + (r/sigma_r)**2, 0) +
                               imag_residuals.reduce((sum, r) => sum + (r/sigma_i)**2, 0);
                const red_chi_sqr = chi_sqr / (n_dat - n_var);

                // Update report text
                let paramsText = `eps_inf = ${params.eps_inf.toFixed(4)}\n`;
                for (let i = 0; i < n_terms; i++) {
                    paramsText += `\nTerm ${i+1}:\n`;
                    paramsText += `    delta_eps_D${i+1} = ${params[`delta_eps_D${i+1}`].toFixed(4)}\n`;
                    paramsText += `    tau_D${i+1}      = ${params[`tau_D${i+1}`].toExponential(4)} s\n`;
                    paramsText += `    alpha${i+1}      = ${params[`alpha${i+1}`].toFixed(4)}\n`;
                    paramsText += `    delta_eps_L${i+1} = ${params[`delta_eps_L${i+1}`].toFixed(4)}\n`;
                    paramsText += `    omega0${i+1}     = ${params[`omega0${i+1}`].toExponential(4)} rad/s\n`;
                    paramsText += `    gamma${i+1}      = ${params[`gamma${i+1}`].toFixed(4)}\n`;
                }

                const reportText = reportOutput.textContent;
                const updatedReport = reportText.replace(
                    /Using fitted values:[\s\S]*?Fit Statistics/,
                    `Using current values (manual):\n    ${paramsText}\nFit Statistics`
                );

                // Update statistics in report
                const statsUpdate = updatedReport.replace(
                    /chi-square\s*=\s*[\d.]+/,
                    `chi-square    = ${chi_sqr.toFixed(4)}`
                ).replace(
                    /reduced chi-square\s*=\s*[\d.]+/,
                    `reduced chi-square = ${red_chi_sqr.toFixed(4)}`
                );

                reportOutput.textContent = statsUpdate;

                // Update fit quality indicator
                // Use same thresholds as FitEvaluator for consistency
                const score = red_chi_sqr < 0.8 ? 100 :
                             red_chi_sqr < 1.2 ? 80 :
                             red_chi_sqr < 2.0 ? 60 : 30;
                const category = score >= 90 ? "Godly" :
                                score >= 75 ? "Excellent" :
                                score >= 60 ? "Good" : "Poor";

                updateFitQualityIndicator({
                    overall_score: score,
                    overall_category: category
                });

            } catch (err) {
                console.error('Error updating UI:', err);
            } finally {
                // Always clean up proxy objects to prevent memory leaks
                if (modelProxy) modelProxy.destroy();
                if (pyParams) pyParams.destroy();
                if (pyFGhz) pyFGhz.destroy();
            }
        }

        function resetParameters() {
            if (!originalParams || !currentData) return;
            const n_terms = currentData.n_terms;
            setupParameterControls(originalParams, n_terms);
            updateUIFromControls(n_terms);
        }

        function updateFitQualityIndicator(evaluation) {
            const indicator = document.getElementById('fit-quality-indicator');
            const scoreSpan = document.getElementById('fit-quality-score');
            const bar = document.getElementById('fit-quality-bar');

            if (!evaluation) {
                indicator.classList.add('hidden');
                return;
            }

            indicator.classList.remove('hidden');
            const score = evaluation.overall_score;
            const category = evaluation.overall_category;

            scoreSpan.textContent = `${score} (${category})`;

            // Update bar width and color
            bar.style.width = `${score}%`;

            if (score >= 90) {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-green-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-green-50 border border-green-200';
            } else if (score >= 75) {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-blue-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-blue-50 border border-blue-200';
            } else if (score >= 60) {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-yellow-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-yellow-50 border border-yellow-200';
            } else {
                bar.className = 'h-2 rounded-full transition-all duration-300 bg-red-500';
                indicator.className = 'mb-4 p-3 rounded-lg bg-red-50 border border-red-200';
            }
        }

        async function downloadResults() {
            if (!currentData) return;
            setLoadingState(true, 'Preparing download...');
            // Initialize proxy variables for cleanup
            let pyParamsCSV = null;
            let pyFGhz = null;
            let fitted_epsilon_proxy = null;
            let imageProxy = null;

            try {
                const zip = new JSZip();
                const baseFilename = originalFilename.replace(/\.csv$/i, '');
                const n_terms = currentData.n_terms;

                // Get current parameters from controls
                const params = {
                    eps_inf: parseFloat(paramControls['eps_inf'].input.value)
                };

                for (let i = 0; i < n_terms; i++) {
                    params[`delta_eps_D${i+1}`] = parseFloat(paramControls[`delta_eps_D${i+1}`].input.value);
                    params[`tau_D${i+1}`] = parseFloat(paramControls[`tau_D${i+1}`].input.value);
                    params[`alpha${i+1}`] = parseFloat(paramControls[`alpha${i+1}`].input.value);
                    params[`delta_eps_L${i+1}`] = parseFloat(paramControls[`delta_eps_L${i+1}`].input.value);
                    params[`omega0${i+1}`] = parseFloat(paramControls[`omega0${i+1}`].input.value);
                    params[`gamma${i+1}`] = parseFloat(paramControls[`gamma${i+1}`].input.value);
                }

                // 1. Create Fitted Data CSV
                const calculateFunc = pyodide.globals.get('calculate_hybrid_model');
                pyParamsCSV = pyodide.toPy(params);
                pyFGhz = pyodide.toPy(currentData.f_ghz);
                fitted_epsilon_proxy = calculateFunc(pyParamsCSV, pyFGhz, n_terms);

                // Convert complex array properly
                const real = pyodide.globals.get('np').real(fitted_epsilon_proxy).toJs();
                const imag = pyodide.globals.get('np').imag(fitted_epsilon_proxy).toJs();

                // Clean up these proxies immediately after use
                fitted_epsilon_proxy.destroy();
                fitted_epsilon_proxy = null;
                pyParamsCSV.destroy();
                pyParamsCSV = null;
                pyFGhz.destroy();
                pyFGhz = null;

                let csvContent = "Frequency_GHz,fitted_Dk,fitted_Df\n";
                currentData.f_ghz.forEach((f, i) => {
                    const dk = real[i];
                    const df = dk === 0 ? 0 : -imag[i] / dk;
                    csvContent += `${f},${dk},${df}\n`;
                });
                zip.file(`${baseFilename}_fitted_hybrid.csv`, csvContent);

                // 2. Add Matplotlib Plot Image
                const createPlotFunc = pyodide.globals.get('create_downloadable_plot');
                // Pass parameters directly - let Python handle the conversion
                imageProxy = createPlotFunc(params, n_terms);
                const imageData = imageProxy.toJs();
                imageProxy.destroy();
                imageProxy = null;
                zip.file(`${baseFilename}_plot_hybrid.png`, imageData);

                // 3. Add Report (human-readable .txt)
                zip.file(`${baseFilename}_report_hybrid.txt`, reportOutput.textContent);

                // 4. Generate JSON report for database ingestion
                const fullJsonReport = {
                    model: "Hybrid Debye-Lorentz",
                    n_terms: n_terms,
                    timestamp: new Date().toISOString(),
                    input_file: originalFilename,
                    parameters: params,
                    data: {
                        frequency_ghz: currentData.f_ghz,
                        measured: {
                            dk: currentData.measured_dk,
                            df: currentData.measured_df
                        },
                        fitted: {
                            dk: real,
                            df: real.map((dk, i) => {
                                return dk === 0 ? 0 : -imag[i] / dk;
                            })
                        }
                    }
                };

                zip.file(`${baseFilename}_report_hybrid.json`, JSON.stringify(fullJsonReport, null, 2));

                // 5. Generate and Download Zip
                const content = await zip.generateAsync({ type: "blob" });
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);
                link.download = `${baseFilename}_hybrid_results.zip`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

            } catch(err) {
                showError(`Failed to create download package: ${err}`);
            } finally {
                // Always clean up proxy objects to prevent memory leaks
                if (fitted_epsilon_proxy) fitted_epsilon_proxy.destroy();
                if (pyParamsCSV) pyParamsCSV.destroy();
                if (pyFGhz) pyFGhz.destroy();
                if (imageProxy) imageProxy.destroy();
                setLoadingState(false);
            }
        }

        // Set up event listeners
        fileUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                originalFilename = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    fileContent = e.target.result;
                    updateButtonState();
                };
                reader.readAsText(file);
            } else {
                fileContent = null;
                originalFilename = '';
                updateButtonState();
            }
        });

        runButton.addEventListener('click', async () => {
            if (!fileContent || !pyodide) return;
            hideError();
            setLoadingState(true, 'Running analysis...');
            outputDiv.classList.add('hidden');

            try {
                const runAnalysis = pyodide.globals.get('run_analysis');
                const n_terms = parseInt(nTermsSelect.value);
                const fitMethod = fitMethodSelect.value;
                const resultJson = runAnalysis(fileContent, n_terms, fitMethod);
                const result = JSON.parse(resultJson);

                currentData = result;

                const plotData = JSON.parse(result.plot_json);
                plotOutput.innerHTML = '';
                Plotly.newPlot('plot-output', plotData.data, plotData.layout, {responsive: true});

                reportOutput.textContent = result.report;
                displayParameters(result.fitted_params, n_terms);

                // Show fit quality
                if (result.json_data.evaluation) {
                    updateFitQualityIndicator(result.json_data.evaluation);
                }

                outputDiv.classList.remove('hidden');

            } catch (err) {
                console.error(err);
                showError(`An error occurred during analysis: ${err.message}`);
            } finally {
                setLoadingState(false);
            }
        });

        resetButton.addEventListener('click', resetParameters);
        downloadButton.addEventListener('click', downloadResults);

        // Initialize
        main();
        updateButtonState();
    </script>
</body>
</html>