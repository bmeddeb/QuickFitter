<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Havriliak-Negami Model Fitter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.0/full/pyodide.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .btn-disabled {
            background-color: #9ca3af;
            cursor: not-allowed;
            opacity: 0.7;
        }
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
        }
        .model-info {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Havriliak-Negami Model Fitter</h1>
            <p class="mt-2 text-lg text-gray-600">Upload your dielectric spectroscopy data (CSV) to fit it to the Havriliak-Negami model.</p>
            <div class="model-info mt-4 max-w-2xl mx-auto">
                <p class="text-sm">ε*(ω) = ε<sub>∞</sub> + Δε / (1 + (jωτ)<sup>α</sup>)<sup>β</sup></p>
                <p class="text-xs mt-2 opacity-90">where α (0 < α ≤ 1) describes symmetric broadening and β (0 < β ≤ 1) describes asymmetric broadening</p>
            </div>
        </header>

        <div class="bg-white rounded-xl shadow-lg p-6 md:p-8">
            <!-- Controls Section -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center mb-6">
                <div>
                    <label for="file-upload" class="block text-sm font-medium text-gray-700 mb-2">
                        Upload CSV File
                    </label>
                    <div class="flex items-center space-x-4">
                        <input type="file" id="file-upload" accept=".csv" class="block w-full text-sm text-gray-500
                            file:mr-4 file:py-2 file:px-4
                            file:rounded-lg file:border-0
                            file:text-sm file:font-semibold
                            file:bg-blue-50 file:text-blue-700
                            hover:file:bg-blue-100
                        ">
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Expected columns: Frequency (GHz), Dk, Df</p>
                </div>
                <div class="space-y-4">
                    <div>
                        <label for="fit-method" class="block text-sm font-medium text-gray-700">Optimization Method</label>
                        <select id="fit-method" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="least_squares" selected>least_squares (Default)</option>
                            <option value="nelder">nelder</option>
                            <option value="lbfgsb">lbfgsb</option>
                            <option value="differential_evolution">differential_evolution (Global)</option>
                        </select>
                    </div>
                    <button id="run-button" class="w-full bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Run Analysis
                    </button>
                </div>
            </div>

            <!-- Status and Output Section -->
            <div id="status" class="text-center my-4 p-4 bg-gray-50 rounded-lg hidden">
                <div class="flex items-center justify-center">
                    <div class="spinner w-6 h-6 rounded-full border-4 border-gray-300"></div>
                    <p id="status-message" class="ml-4 text-gray-700 font-medium"></p>
                </div>
            </div>

            <div id="output" class="hidden mt-8">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- Plot Display -->
                    <div id="plot-container" class="lg:col-span-2 space-y-4">
                        <div class="border border-gray-200 rounded-lg bg-gray-50 p-2">
                            <div id="plot-output"></div>
                        </div>
                        <!-- Cole-Cole Plot -->
                        <div class="border border-gray-200 rounded-lg bg-gray-50 p-2">
                            <div id="cole-cole-plot" style="height: 400px;"></div>
                        </div>
                    </div>

                    <!-- Parameter Controls -->
                    <div id="controls-panel" class="lg:col-span-1 bg-white p-6 rounded-lg border">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-gray-800">Adjust Fit Parameters</h3>
                            <div class="flex space-x-2">
                                <button id="reset-button" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-1 px-3 rounded-lg">
                                    Reset
                                </button>
                                <button id="download-button" class="text-sm bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 px-3 rounded-lg">
                                    Download
                                </button>
                            </div>
                        </div>

                        <!-- Fit Quality Indicator -->
                        <div id="fit-quality-indicator" class="mb-4 p-3 rounded-lg hidden">
                            <div class="flex items-center justify-between">
                                <span class="text-sm font-medium">Fit Quality:</span>
                                <span id="fit-quality-score" class="text-lg font-bold"></span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                                <div id="fit-quality-bar" class="h-2 rounded-full transition-all duration-300"></div>
                            </div>
                            <!-- Warnings Display -->
                            <div id="fit-warnings" class="mt-3 space-y-1 hidden">
                                <div class="text-xs font-medium text-gray-600 mb-1">Warnings:</div>
                                <div id="warnings-container" class="space-y-1"></div>
                            </div>
                        </div>

                        <!-- Model Type Display -->
                        <div id="model-type-indicator" class="mb-4 p-3 rounded-lg bg-indigo-50 border border-indigo-200 hidden">
                            <div class="text-sm font-medium text-indigo-800">
                                <span id="model-type-text"></span>
                            </div>
                        </div>

                        <div class="space-y-6">
                            <!-- eps_inf -->
                            <div>
                                <label for="eps_inf_slider" class="block text-sm font-medium text-gray-700">ε<sub>∞</sub> (Epsilon Infinity)</label>
                                <input type="range" id="eps_inf_slider" class="mt-1">
                                <input type="number" id="eps_inf_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                            <!-- delta_eps -->
                            <div>
                                <label for="delta_eps_slider" class="block text-sm font-medium text-gray-700">Δε (Delta Epsilon)</label>
                                <input type="range" id="delta_eps_slider" class="mt-1">
                                <input type="number" id="delta_eps_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm">
                            </div>
                            <!-- tau -->
                            <div>
                                <label for="tau_slider" class="block text-sm font-medium text-gray-700">τ (Relaxation Time, s)</label>
                                <input type="range" id="tau_slider" class="mt-1" step="any">
                                <input type="number" id="tau_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm" step="any">
                            </div>
                            <!-- alpha -->
                            <div>
                                <label for="alpha_slider" class="block text-sm font-medium text-gray-700">α (Symmetric Broadening)</label>
                                <input type="range" id="alpha_slider" class="mt-1" min="0.01" max="1" step="0.01">
                                <input type="number" id="alpha_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm" min="0.01" max="1" step="0.01">
                            </div>
                            <!-- beta -->
                            <div>
                                <label for="beta_slider" class="block text-sm font-medium text-gray-700">β (Asymmetric Broadening)</label>
                                <input type="range" id="beta_slider" class="mt-1" min="0.01" max="1" step="0.01">
                                <input type="number" id="beta_input" class="mt-2 w-full p-2 border border-gray-300 rounded-md text-sm" min="0.01" max="1" step="0.01">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Report Display -->
                <div class="mt-8">
                    <h2 class="text-2xl font-bold mb-4 text-gray-800">Fit Report</h2>
                    <div class="bg-gray-900 text-white font-mono text-sm p-6 rounded-lg overflow-x-auto">
                        <pre id="report-output"></pre>
                    </div>
                </div>
            </div>
             <!-- Error Display -->
            <div id="error-box" class="hidden mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                <h3 class="font-bold">An Error Occurred</h3>
                <p id="error-message"></p>
            </div>
        </div>
        <footer class="text-center mt-8 text-sm text-gray-500">
            <p>Powered by Pyodide, lmfit, and plotly</p>
            <div class="border-t border-gray-300 pt-2 mt-2">
            <p class="font-semibold text-gray-700">Citation</p>
            <p class="italic">Meddeb, B., & Meddeb, A. (2025). QuickFitter: Interactive Dielectric Data Fitting Tool - Havriliak-Negami Model.
            <br>Available at: <a href="https://github.com/bmeddeb/QuickFitter" class="text-blue-600 hover:underline">https://github.com/bmeddeb/QuickFitter</a></p>
        </div>
        </footer>
    </div>

    <script type="text/javascript">
        // DOM Elements
        const fileUpload = document.getElementById('file-upload');
        const runButton = document.getElementById('run-button');
        const resetButton = document.getElementById('reset-button');
        const downloadButton = document.getElementById('download-button');
        const fitMethodSelect = document.getElementById('fit-method');
        const statusDiv = document.getElementById('status');
        const statusMessage = document.getElementById('status-message');
        const outputDiv = document.getElementById('output');
        const plotOutput = document.getElementById('plot-output');
        const reportOutput = document.getElementById('report-output');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');

        // Parameter Controls
        const paramControls = {
            eps_inf: { slider: document.getElementById('eps_inf_slider'), input: document.getElementById('eps_inf_input') },
            delta_eps: { slider: document.getElementById('delta_eps_slider'), input: document.getElementById('delta_eps_input') },
            tau: { slider: document.getElementById('tau_slider'), input: document.getElementById('tau_input'), isLog: true },
            alpha: { slider: document.getElementById('alpha_slider'), input: document.getElementById('alpha_input') },
            beta: { slider: document.getElementById('beta_slider'), input: document.getElementById('beta_input') },
        };

        // Global State
        let pyodide = null;
        let fileContent = null;
        let isPyodideReady = false;
        let currentData = null;
        let originalFilename = '';

        // Python Script
        const pythonScript = `
import sys
import io
import json
from datetime import datetime
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.io as pio
from lmfit import Minimizer, Parameters, fit_report
import math
import logging
from typing import Dict, Tuple, Any, List, Optional
from dataclasses import dataclass, field
from scipy.optimize import differential_evolution

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Global variables to store data
global_f_ghz = None
global_complex_epsilon = None
global_correlation_matrix = None
global_measured_dk = None
global_measured_df = None

def load_data(csv_content):
    global global_f_ghz, global_complex_epsilon
    try:
        data = pd.read_csv(io.StringIO(csv_content)).dropna()
        f_ghz = data.iloc[:, 0].values
        dk = data.iloc[:, 1].values
        df = data.iloc[:, 2].values
        complex_epsilon = dk - 1j * (dk * df)
        global_f_ghz = f_ghz
        global_complex_epsilon = complex_epsilon
        return f_ghz, complex_epsilon
    except Exception as e:
        raise ValueError(f"Failed to parse CSV: {e}")

def estimate_initial_parameters(f_ghz, complex_epsilon):
    """Estimate initial parameters for Havriliak-Negami model."""
    dk = np.real(complex_epsilon)
    df = -np.imag(complex_epsilon) / np.real(complex_epsilon)

    # Estimate eps_inf and eps_s
    high_freq_idx = int(0.8 * len(dk))
    low_freq_idx = int(0.2 * len(dk))

    eps_inf_init = np.median(dk[high_freq_idx:]) if high_freq_idx < len(dk) else dk[-1]
    eps_s_init = np.median(dk[:low_freq_idx]) if low_freq_idx > 0 else dk[0]

    # Ensure physical constraints
    eps_inf_init = max(1.0, eps_inf_init)
    eps_s_init = max(eps_inf_init + 0.1, eps_s_init)

    delta_eps_init = eps_s_init - eps_inf_init

    # Estimate tau from peak in loss
    max_loss_idx = np.argmax(-np.imag(complex_epsilon))
    f_max = f_ghz[max_loss_idx]
    tau_init = 1 / (2 * np.pi * f_max * 1e9)

    # Initial guess for broadening parameters
    alpha_init = 0.9
    beta_init = 0.95

    return {
        'eps_inf': eps_inf_init,
        'delta_eps': delta_eps_init,
        'tau': tau_init,
        'alpha': alpha_init,
        'beta': beta_init
    }

def calculate_model(params, f_ghz):
    """Calculate HN model."""
    p = params
    omega = 2 * np.pi * f_ghz * 1e9

    with np.errstate(divide='ignore', invalid='ignore'):
        if p['tau'] <= 0 or p['alpha'] <= 0 or p['alpha'] > 1 or p['beta'] <= 0 or p['beta'] > 1:
            return np.full_like(f_ghz, np.nan, dtype=complex)
        else:
            jwτ = 1j * omega * p['tau']
            denominator = (1 + jwτ**p['alpha'])**p['beta']
            eps_complex = p['eps_inf'] + p['delta_eps'] / denominator

    return eps_complex

def residual(params, f_ghz, complex_epsilon_data):
    """Residual function for HN model."""
    p_dict = params.valuesdict()
    model_epsilon = calculate_model(p_dict, f_ghz)

    scale_real = np.max(np.abs(np.real(complex_epsilon_data))) or 1.0
    scale_imag = np.max(np.abs(np.imag(complex_epsilon_data))) or 1.0

    real_residual = (np.real(model_epsilon) - np.real(complex_epsilon_data)) / scale_real
    imag_residual = (np.imag(model_epsilon) - np.imag(complex_epsilon_data)) / scale_imag

    return np.concatenate([real_residual, imag_residual])

def create_plotly_plot(f_ghz, measured_eps, fitted_eps):
    """Create main frequency domain plots."""
    fig = make_subplots(rows=2, cols=1, subplot_titles=('Real Permittivity', 'Loss Tangent'))

    fig.add_trace(go.Scatter(x=f_ghz, y=np.real(measured_eps), mode='markers',
                            name='Measured Dk', marker=dict(color='black')), row=1, col=1)
    fig.add_trace(go.Scatter(x=f_ghz, y=np.real(fitted_eps), mode='lines',
                            name='Fitted Dk', line=dict(color='red')), row=1, col=1)

    measured_df = -np.imag(measured_eps) / np.real(measured_eps)
    fitted_df = -np.imag(fitted_eps) / np.real(fitted_eps)

    fig.add_trace(go.Scatter(x=f_ghz, y=measured_df, mode='markers',
                            name='Measured Df', marker=dict(color='black'), showlegend=False), row=2, col=1)
    fig.add_trace(go.Scatter(x=f_ghz, y=fitted_df, mode='lines',
                            name='Fitted Df', line=dict(color='red'), showlegend=False), row=2, col=1)

    fig.update_xaxes(title_text="Frequency (GHz)", row=1, col=1)
    fig.update_yaxes(title_text="Dielectric Constant (Dk)", row=1, col=1)
    fig.update_xaxes(title_text="Frequency (GHz)", row=2, col=1)
    fig.update_yaxes(title_text="Dissipation Factor (Df)", row=2, col=1)

    fig.update_layout(height=600, margin=dict(l=20, r=20, t=40, b=20),
                     template="plotly_white",
                     legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99))

    return pio.to_json(fig)

def create_cole_cole_plot(f_ghz, measured_eps, fitted_eps):
    """Create Cole-Cole plot."""
    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=np.real(measured_eps),
        y=-np.imag(measured_eps),
        mode='markers',
        name='Measured',
        marker=dict(color='black', size=6)
    ))

    fig.add_trace(go.Scatter(
        x=np.real(fitted_eps),
        y=-np.imag(fitted_eps),
        mode='lines',
        name='Fitted',
        line=dict(color='red', width=2)
    ))

    fig.update_layout(
        title="Cole-Cole Plot",
        xaxis_title="ε' (Real Permittivity)",
        yaxis_title="ε'' (Imaginary Permittivity)",
        height=400,
        template="plotly_white",
        legend=dict(yanchor="top", y=0.99, xanchor="right", x=0.99)
    )

    return pio.to_json(fig)

def calculate_model_from_params(eps_inf, delta_eps, tau, alpha, beta):
    """Calculate HN model from manual parameters."""
    global global_f_ghz
    if global_f_ghz is None:
        return json.dumps({"error": "No data loaded"})

    params = {'eps_inf': eps_inf, 'delta_eps': delta_eps, 'tau': tau, 'alpha': alpha, 'beta': beta}
    eps_complex = calculate_model(params, global_f_ghz)

    eps_prime = np.real(eps_complex)
    eps_double_prime = -np.imag(eps_complex)

    return json.dumps({
        "eps_prime": eps_prime.tolist(),
        "eps_double_prime": eps_double_prime.tolist()
    })

def run_analysis(csv_content, method):
    """Run the HN model fitting analysis."""
    global global_f_ghz, global_complex_epsilon, global_measured_dk, global_measured_df

    f_ghz, complex_epsilon_data = load_data(csv_content)

    global_measured_dk = np.real(complex_epsilon_data).tolist()
    global_measured_df = (-np.imag(complex_epsilon_data) / np.real(complex_epsilon_data)).tolist()

    initial_params = estimate_initial_parameters(f_ghz, complex_epsilon_data)

    if method == 'differential_evolution':
        bounds = [
            (1.0, np.real(complex_epsilon_data).max()),
            (0.1, np.real(complex_epsilon_data).max()),
            (1e-15, 1e-6),
            (0.01, 1.0),
            (0.01, 1.0)
        ]

        def objective(x):
            params_dict = {
                'eps_inf': x[0], 'delta_eps': x[1], 'tau': x[2], 'alpha': x[3], 'beta': x[4]
            }
            model = calculate_model(params_dict, f_ghz)
            scale_real = np.max(np.abs(np.real(complex_epsilon_data))) or 1.0
            scale_imag = np.max(np.abs(np.imag(complex_epsilon_data))) or 1.0
            real_res = (np.real(model) - np.real(complex_epsilon_data)) / scale_real
            imag_res = (np.imag(model) - np.imag(complex_epsilon_data)) / scale_imag
            return np.sum(real_res**2) + np.sum(imag_res**2)

        result_de = differential_evolution(objective, bounds, seed=42, maxiter=1000)
        fit_params = {
            'eps_inf': float(result_de.x[0]),
            'delta_eps': float(result_de.x[1]),
            'tau': float(result_de.x[2]),
            'alpha': float(result_de.x[3]),
            'beta': float(result_de.x[4])
        }

    else:
        params = Parameters()
        dk_data = np.real(complex_epsilon_data)
        params.add('eps_inf', value=initial_params['eps_inf'], min=1.0, max=dk_data.max())
        params.add('delta_eps', value=initial_params['delta_eps'], min=0.1, max=dk_data.max())
        params.add('tau', value=initial_params['tau'], min=1e-15, max=1e-6)
        params.add('alpha', value=initial_params['alpha'], min=0.01, max=1.0)
        params.add('beta', value=initial_params['beta'], min=0.01, max=1.0)

        minimizer = Minimizer(residual, params, fcn_args=(f_ghz, complex_epsilon_data))
        result = minimizer.minimize(method=method)

        fit_params = {p: float(v.value) for p, v in result.params.items()}

    fitted_epsilon = calculate_model(fit_params, f_ghz)

    # Generate basic report
    f_relax = 1 / (2 * np.pi * fit_params['tau']) / 1e9 if fit_params['tau'] > 0 else 0

    full_report = f"""Havriliak-Negami Fit Report
{'=' * 50}
Date: {datetime.now()}

Model and Parameters
--------------------------------------------------
ε*(ω) = ε_∞ + Δε / (1 + (jωτ)^α)^β

Fitted Parameters:
    eps_inf   = {fit_params['eps_inf']:.4f}
    delta_eps = {fit_params['delta_eps']:.4f}
    tau       = {fit_params['tau']:.4e} s
    alpha     = {fit_params['alpha']:.4f}
    beta      = {fit_params['beta']:.4f}

    f_relax   = {f_relax:.4f} GHz
"""

    plot_json = create_plotly_plot(f_ghz, complex_epsilon_data, fitted_epsilon)
    cole_cole_json = create_cole_cole_plot(f_ghz, complex_epsilon_data, fitted_epsilon)

    return_data = {
        "report": full_report,
        "plot_json": plot_json,
        "cole_cole_json": cole_cole_json,
        "f_ghz": f_ghz.tolist(),
        "fitted_params": fit_params,
        "measured_dk": global_measured_dk,
        "measured_df": global_measured_df,
        "model_type": "Havriliak-Negami",
        "model_desc": f"α = {fit_params['alpha']:.3f}, β = {fit_params['beta']:.3f}"
    }
    return json.dumps(return_data)
`;

        // Initialize Pyodide
        async function initializePyodide() {
            try {
                showStatus("Initializing Python environment...");
                pyodide = await loadPyodide();

                showStatus("Installing required packages...");
                await pyodide.loadPackage(["numpy", "pandas", "matplotlib", "scipy"]);

                showStatus("Installing lmfit...");
                await pyodide.runPython("import micropip; await micropip.install('lmfit')");

                showStatus("Installing plotly...");
                await pyodide.runPython("import micropip; await micropip.install('plotly')");

                showStatus("Setting up analysis environment...");
                pyodide.runPython(pythonScript);

                isPyodideReady = true;
                hideStatus();
                console.log("Pyodide initialized successfully");
            } catch (error) {
                showError("Failed to initialize Python environment: " + error.message);
                console.error("Pyodide initialization error:", error);
            }
        }

        // UI Helper Functions
        function showStatus(message) {
            statusMessage.textContent = message;
            statusDiv.classList.remove('hidden');
        }

        function hideStatus() {
            statusDiv.classList.add('hidden');
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
            hideStatus();
        }

        function hideError() {
            errorBox.classList.add('hidden');
        }

        function setupParameterControls(params) {
            // Set up sliders and inputs for each parameter
            Object.entries(paramControls).forEach(([paramName, controls]) => {
                const value = params[paramName];

                if (paramName === 'tau') {
                    // Log scale for tau
                    const logValue = Math.log10(value);
                    controls.slider.min = -15;
                    controls.slider.max = -6;
                    controls.slider.step = 0.1;
                    controls.slider.value = logValue;
                } else if (paramName === 'alpha' || paramName === 'beta') {
                    controls.slider.min = 0.01;
                    controls.slider.max = 1;
                    controls.slider.step = 0.01;
                    controls.slider.value = value;
                } else {
                    // Linear scale for eps_inf and delta_eps
                    const minVal = 0.1;
                    const maxVal = value * 3;
                    controls.slider.min = minVal;
                    controls.slider.max = maxVal;
                    controls.slider.step = (maxVal - minVal) / 1000;
                    controls.slider.value = value;
                }

                controls.input.value = value;

                // Add event listeners
                controls.slider.addEventListener('input', () => updateParameter(paramName));
                controls.input.addEventListener('input', () => updateParameter(paramName));
            });
        }

        function updateParameter(paramName) {
            const controls = paramControls[paramName];
            let value;

            if (paramName === 'tau') {
                // Convert from log scale
                value = Math.pow(10, parseFloat(controls.slider.value));
            } else {
                value = parseFloat(controls.slider.value);
            }

            // Update the input field
            controls.input.value = value;

            // Update plots with new parameters
            updatePlots();
        }

        function updatePlots() {
            if (!isPyodideReady || !currentData) return;

            const params = getCurrentParameters();

            try {
                // Calculate new model
                const result = pyodide.runPython(`calculate_model_from_params(${params.eps_inf}, ${params.delta_eps}, ${params.tau}, ${params.alpha}, ${params.beta})`);
                const modelData = JSON.parse(result);

                if (modelData.error) {
                    console.error("Model calculation error:", modelData.error);
                    return;
                }

                // Update main plot
                const fig_data = {
                    data: [
                        {
                            x: currentData.f_ghz,
                            y: currentData.measured_dk,
                            mode: 'markers',
                            name: 'Measured Dk',
                            marker: {color: 'black'}
                        },
                        {
                            x: currentData.f_ghz,
                            y: modelData.eps_prime,
                            mode: 'lines',
                            name: 'Fitted Dk',
                            line: {color: 'red'}
                        },
                        {
                            x: currentData.f_ghz,
                            y: currentData.measured_df,
                            mode: 'markers',
                            name: 'Measured Df',
                            marker: {color: 'black'},
                            xaxis: 'x2',
                            yaxis: 'y2'
                        },
                        {
                            x: currentData.f_ghz,
                            y: modelData.eps_double_prime.map((val, i) => val / modelData.eps_prime[i]),
                            mode: 'lines',
                            name: 'Fitted Df',
                            line: {color: 'red'},
                            xaxis: 'x2',
                            yaxis: 'y2'
                        }
                    ],
                    layout: {
                        grid: {rows: 2, columns: 1, pattern: 'independent'},
                        xaxis: {title: 'Frequency (GHz)'},
                        yaxis: {title: 'Dielectric Constant (Dk)'},
                        xaxis2: {title: 'Frequency (GHz)'},
                        yaxis2: {title: 'Dissipation Factor (Df)'},
                        height: 600,
                        template: 'plotly_white'
                    }
                };

                Plotly.react('plot-output', fig_data.data, fig_data.layout);

                // Update Cole-Cole plot
                const cole_cole_data = {
                    data: [
                        {
                            x: currentData.measured_dk,
                            y: currentData.measured_dk.map((dk, i) => dk * currentData.measured_df[i]),
                            mode: 'markers',
                            name: 'Measured',
                            marker: {color: 'black', size: 6}
                        },
                        {
                            x: modelData.eps_prime,
                            y: modelData.eps_double_prime,
                            mode: 'lines',
                            name: 'Fitted',
                            line: {color: 'red', width: 2}
                        }
                    ],
                    layout: {
                        title: 'Cole-Cole Plot',
                        xaxis: {title: "ε' (Real Permittivity)"},
                        yaxis: {title: "ε'' (Imaginary Permittivity)"},
                        height: 400,
                        template: 'plotly_white'
                    }
                };

                Plotly.react('cole-cole-plot', cole_cole_data.data, cole_cole_data.layout);

            } catch (error) {
                console.error("Error updating plots:", error);
            }
        }

        function getCurrentParameters() {
            return {
                eps_inf: parseFloat(paramControls.eps_inf.input.value),
                delta_eps: parseFloat(paramControls.delta_eps.input.value),
                tau: parseFloat(paramControls.tau.input.value),
                alpha: parseFloat(paramControls.alpha.input.value),
                beta: parseFloat(paramControls.beta.input.value)
            };
        }

        // Event Listeners
        runButton.addEventListener('click', async () => {
            if (!fileContent) {
                showError("Please upload a CSV file first.");
                return;
            }

            if (!isPyodideReady) {
                showError("Python environment is not ready. Please wait for initialization to complete.");
                return;
            }

            hideError();
            runButton.disabled = true;
            runButton.classList.add('btn-disabled');

            const method = fitMethodSelect.value;
            showStatus(`Running ${method} optimization...`);

            try {
                const result = pyodide.runPython(`run_analysis("""${fileContent}""", "${method}")`);
                const data = JSON.parse(result);

                currentData = data;

                // Display results
                reportOutput.textContent = data.report;

                // Create plots
                const plotData = JSON.parse(data.plot_json);
                Plotly.newPlot('plot-output', plotData.data, plotData.layout);

                const coleColeData = JSON.parse(data.cole_cole_json);
                Plotly.newPlot('cole-cole-plot', coleColeData.data, coleColeData.layout);

                // Setup parameter controls
                setupParameterControls(data.fitted_params);

                // Show model type
                document.getElementById('model-type-text').textContent = data.model_desc;
                document.getElementById('model-type-indicator').classList.remove('hidden');

                outputDiv.classList.remove('hidden');
                hideStatus();

            } catch (error) {
                showError(`Analysis failed: ${error.message}`);
                console.error("Analysis error:", error);
            } finally {
                runButton.disabled = false;
                runButton.classList.remove('btn-disabled');
            }
        });

        fileUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                originalFilename = file.name;
                const reader = new FileReader();
                reader.onload = (e) => {
                    fileContent = e.target.result;
                };
                reader.readAsText(file);
            }
        });

        resetButton.addEventListener('click', () => {
            if (currentData && currentData.fitted_params) {
                setupParameterControls(currentData.fitted_params);
                updatePlots();
            }
        });

        downloadButton.addEventListener('click', () => {
            if (!currentData) return;

            const params = getCurrentParameters();
            const reportContent = `Havriliak-Negami Fit Report\nParameters: ${JSON.stringify(params, null, 2)}`;

            const blob = new Blob([reportContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hn_fit_report.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Initialize the application
        window.addEventListener('load', () => {
            initializePyodide();
        });
    </script>

</body>
</html>